C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OMF2 OPTIMIZE(0,SIZE) BROWSE ORDER INCDIR(..\Src;.\LCD) DEB
                    -UG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file    Project/main.c 
   4            * @author  MCD Application Team
   5            * @version V2.2.0
   6            * @date    30-September-2014
   7            * @brief   Main program body
   8           */
   9          /* Includes ------------------------------------------------------------------*/
  10          #include "main.h"
  11          #include "lcd.h"
  12          #include "ABencoder.h"
  13          #include "uarttask.h"
  14          #include "spi_flash.h"
  15          #include "eeprom.h"
  16          #include "SaveConfigfile.h"
  17          #include "uuid.h"
  18          /* Private defines -----------------------------------------------------------*/
  19          
  20          #define NOREPLSYTIMES 5
  21          #define MAXSTARTDELAYTIME 10
  22          #define MINSTARTDELAYTIME 3
  23          
  24          
  25          #define EX2             0x10
  26          #define EX3             0x20
  27          #define EX4             0x40
  28          
  29          
  30          sbit LED = P2^1;
  31          
  32          /* Private function prototypes -----------------------------------------------*/
  33          /* Private functions ---------------------------------------------------------*/
  34          void InitLcd(void);
  35          
  36           
  37           
  38          u8 UsbCmdUpdate=0;
  39          u8 usbCmdCode=0;
  40          u8 usbWRAddr,usbWRData;
  41          //UARTST_PKG  uart1rcpkg;
  42          UARTST_PKG uart2rcpkg;
  43          //UARTST_PKG uart3rcpkg;
  44          UARTST4_PKG uart4rcpkg;
  45          
  46          uint8_t LCD_DISPiD=0;
  47          uint8_t NeedUpdateLEDValue=0,NeedUpdateConnect=0,NeedSaveData=0;
  48          
  49          u8 DriverBoardConnetStatus=0;
  50          u8 DriverBoardNoReplyCounter=0;
  51          u8 LedShareCounter=0;
  52          u8 SelectData=0;
  53          u8 UpdateTHCounter=0;
  54          u8 RunModel=0;
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 2   

  55          u8 StartDelayCounter=0;
  56          u8 SaveEEpromDelaycounter=0;
  57          u8 Temperature=0,Humidity=0;
  58          u8 GetDriverBoardReturn=0;
  59          
  60          u8 ABEncoderACCCounter=0;
  61          u8 ABEncoderAAC=1;
  62          
  63          
  64          u8 SelectChDelayCounter=0;
  65          u8 AutoOnLedCh=0;
  66          u8 MovetoOtherLedch=0;
  67          
  68          void delay_us(uint16_t dt) 
  69          {
  70   1        dt = dt<<1;
  71   1        while (--dt) WDTRST;
  72   1      }
  73            
  74          
  75          
  76          void delay_ms(uint16_t dt)
  77          {
  78   1       while (dt>0)
  79   1        {
  80   2        delay_us(400);
  81   2        dt--;
  82   2        }
  83   1      }
  84          
  85          void ClearMemory(uint8_t * ptr,uint8_t len)
  86          {
  87   1        uint8_t i;
  88   1         for (i=0;i<len;i++)  
  89   1          {
  90   2          *ptr=0;
  91   2          ptr++;
  92   2          }
  93   1      }
  94          
  95          void SetMemory(uint8_t * ptr,uint8_t len)
  96          {
  97   1        uint8_t i;
  98   1         for (i=0;i<len;i++)  
  99   1          {
 100   2          *ptr=0xff;
 101   2          ptr++;
 102   2          }
 103   1      }
 104          
 105          void Memcpy2(u8* src, u8* dec,u8 len)
 106          {
 107   1        uint8_t i;
 108   1         for (i=0;i<len;i++)  
 109   1          {
 110   2          *dec=*src;
 111   2          src++;
 112   2          dec++;
 113   2          }
 114   1      }
 115          
 116          u8 cmpMemory(u8* ptr, u8* dec ,u8 len)
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 3   

 117          {
 118   1        uint8_t i;
 119   1         for (i=0;i<len;i++)  
 120   1          {
 121   2          if ((*dec)!=(*ptr)) return 0;
 122   2          ptr++;
 123   2          dec++;
 124   2          }
 125   1         return 1;
 126   1      }
 127          
 128          
 129          
 130          
 131          
 132          void Gpio_Init(void)
 133          {
 134   1        
 135   1        P26=1; P27=1;P00=1;P01=1; // 按键1-4
 136   1      
 137   1        
 138   1        P32=1;P33=1;P36=0;P37=1;//编码器输入
 139   1        P20=1; //speaker
 140   1        LED=0; //LED
 141   1        
 142   1        P0M0=0;
 143   1        P0M1=0;
 144   1        
 145   1        P1M0=0;
 146   1        P1M1=0;+
 147   1        
 148   1        P2M0=0x2E;
 149   1        P2M1=0;
 150   1      
 151   1        P3M0=0X40;
 152   1        P3M1=0;
 153   1      
 154   1        P5M0=0X10;
 155   1        P5M1=0;
 156   1      
 157   1        IT1 = 1;                                    //使能INT1 下降沿中断
 158   1          EX1 = 1;                                    //使能INT1中断
 159   1        INTCLKO = EX3;                              //使能INT3中断
 160   1      
 161   1      }
 162          
 163          void Beep(void)
 164          {
 165   1        P20=0;  //SPK
 166   1        delay_ms(100);
 167   1        P20=1;
 168   1      }
 169          
 170          void Timer0Init(void)   //20毫秒@33.1776MHz
 171          {
 172   1        AUXR &= 0x7F;   //定时器时钟12T模式
 173   1        TMOD &= 0xF0;   //设置定时器模式
 174   1        TL0 = 0x00;   //设置定时初值
 175   1        TH0 = 0x28;   //设置定时初值
 176   1        ET0 = 1;                                   
 177   1        TF0 = 0;    //清除TF0标志
 178   1        TR0 = 1;    //定时器0开始计时
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 4   

 179   1      }
 180          
 181          void UpdateSelectedLedOnOff(u8 nonoff)
 182          {
 183   1        if (nonoff==0) MovetoOtherLedch=0;
 184   1        SaveLedData0.LedOnOff=nonoff;
 185   1        UpdateLCDLEDCloum(SaveLedData0.SelectedLedChanel,SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel],Sa
             -veLedData0.LedOnOff);
 186   1      }
 187          
 188          
 189          void UpdateSelcetedLed(u8 newSelCh)
 190          {
 191   1      
 192   1        if (SaveLedData0.SelectedLedChanel!=newSelCh)
 193   1        {
 194   2          UpdateLCDLEDCloum(SaveLedData0.SelectedLedChanel,SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel],0
             -);
 195   2          UpdateLCDLEDSelected(SaveLedData0.SelectedLedChanel,0); 
 196   2          SaveLedData0.SelectedLedChanel=newSelCh;
 197   2          UpdateLCDLEDSelected(SaveLedData0.SelectedLedChanel,1); 
 198   2          UpdateSelectedLedOnOff(SaveLedData0.LedOnOff);
 199   2        }
 200   1      }
 201          
 202          
 203          
 204          //time0 定时超时判断
 205          void Time0OutDelaySub(void)
 206          {
 207   1      
 208   1        if (uart2rcpkg.RecStatus!=REC_HEAD1)
 209   1          {
 210   2          uart2Memory.UartPkgTimeoutCounter++;
 211   2          if (uart2Memory.UartPkgTimeoutCounter>50)
 212   2            {
 213   3            uart2Memory.UartPkgTimeoutCounter=0;
 214   3            uart2rcpkg.RecStatus=REC_HEAD1;
 215   3            }
 216   2          }
 217   1          
 218   1        if (uart4rcpkg.RecStatus!=REC2_HEAD1)
 219   1          {
 220   2          uart4rcpkg.UartPkgTimeoutCounter++;
 221   2          if (uart4rcpkg.UartPkgTimeoutCounter>50)
 222   2            {
 223   3            uart4rcpkg.UartPkgTimeoutCounter=0;
 224   3            uart4rcpkg.RecStatus=REC2_HEAD1;
 225   3            }
 226   2          }
 227   1      
 228   1        if (uart4rcpkg.UsbCmdStatus!=REC4_HEAD1)
 229   1          {
 230   2          uart4rcpkg.UartPkgTimeoutCounter++;
 231   2          if (uart4rcpkg.UartPkgTimeoutCounter>50)
 232   2            {
 233   3            uart4rcpkg.UartPkgTimeoutCounter=0;
 234   3            uart4rcpkg.UsbCmdStatus=REC4_HEAD1;
 235   3            }
 236   2          }
 237   1      
 238   1        if (SaveLedData0.Saveed==0 &&  ABEncoderDir==0) 
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 5   

 239   1          {
 240   2          if (SaveEEpromDelaycounter>=150)   //3秒
 241   2            {
 242   3            NeedSaveData=1;
 243   3            }
 244   2          else
 245   2            {
 246   3            SaveEEpromDelaycounter++;
 247   3            }
 248   2          }
 249   1        else 
 250   1          {
 251   2          SaveEEpromDelaycounter=0;
 252   2          }
 253   1        
 254   1      
 255   1        if (ABEncoderAAC!=1) ABEncoderACCCounter++;
 256   1      
 257   1        if (ABEncoderACCCounter>=15)
 258   1          {
 259   2          ABEncoderACCCounter=0;
 260   2          ABEncoderAAC=1;
 261   2          }
 262   1        
 263   1      
 264   1        if ((LCD_DISPiD==1) && (SaveLedData0.LedOnOff==0) && (MovetoOtherLedch==1)) SelectChDelayCounter++;//自动
 265   1          if(SaveLedData0.SelectedLedChanel==1&&SaveLedData0.PurpleLamp==0)
 266   1          {
 267   2          if (SelectChDelayCounter>75)  
 268   2          {
 269   3          SelectChDelayCounter=0;
 270   3          AutoOnLedCh=0;
 271   3          MovetoOtherLedch=0;
 272   3           }
 273   2          }
 274   1          else
 275   1          {
 276   2          if (SelectChDelayCounter>75)  
 277   2          {
 278   3          SelectChDelayCounter=0;
 279   3          AutoOnLedCh=1;
 280   3          MovetoOtherLedch=0;
 281   3           }
 282   2          }
 283   1        
 284   1      
 285   1        LedShareCounter++;
 286   1        if (LedShareCounter==25)   //0.5秒
 287   1          {
 288   2          LED=!LED;
 289   2          
 290   2          }
 291   1        else if (LedShareCounter>=50)  //1秒
 292   1          {
 293   2          LedShareCounter=0;
 294   2          NeedUpdateLEDValue=1;
 295   2          
 296   2          LED=!LED;
 297   2          if (StartDelayCounter<MAXSTARTDELAYTIME)  StartDelayCounter++;
 298   2          
 299   2        if (GetDriverBoardReturn==1) 
 300   2          {
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 6   

 301   3            DriverBoardNoReplyCounter=0;
 302   3            if (DriverBoardConnetStatus==0) NeedUpdateConnect=1;
 303   3            DriverBoardConnetStatus=1;
 304   3            
 305   3          }
 306   2        else 
 307   2          {
 308   3            if (DriverBoardConnetStatus==1) DriverBoardNoReplyCounter++;
 309   3            if (DriverBoardNoReplyCounter>NOREPLSYTIMES)  
 310   3              {
 311   4              DriverBoardNoReplyCounter=0;
 312   4              DriverBoardConnetStatus=0;
 313   4              NeedUpdateConnect=1;
 314   4              }
 315   3            //GetDriverBoardReturn=0;
 316   3          } 
 317   2          }
 318   1      }
 319          
 320          void InitLcd(void)
 321          {
 322   1        if (GetDriverBoardReturn==0)  //驱动板没有返回
 323   1          {
 324   2          DisplayDisconnect();
 325   2          }
 326   1        else 
 327   1          {
 328   2          LCD_DrawWorkScreen();
 329   2          }
 330   1      }
 331          
 332          
 333          
 334          
 335          
 336          void ReturnWrUart4CmdUsb(u8 Wraddr,u8 WrData)
 337          {
 338   1         u8 addrsum=0;
 339   1         
 340   1         while (uart4rcpkg.busy==1) WDTRST;    
 341   1         uart4rcpkg.busy=1;
 342   1         S4BUF=0x69;
 343   1         while (uart4rcpkg.busy==1) WDTRST;    
 344   1         uart4rcpkg.busy=1;
 345   1         S4BUF=0x96;
 346   1         while (uart4rcpkg.busy==1) WDTRST;    
 347   1         uart4rcpkg.busy=1;
 348   1         S4BUF=usbCmdCode;
 349   1         addrsum+=usbCmdCode;
 350   1          while (uart4rcpkg.busy==1) WDTRST;    
 351   1         uart4rcpkg.busy=1;
 352   1         S4BUF=Wraddr;
 353   1         addrsum+=Wraddr;
 354   1          while (uart4rcpkg.busy==1) WDTRST;    
 355   1         uart4rcpkg.busy=1;
 356   1         S4BUF=WrData;
 357   1         addrsum+=WrData;
 358   1         while (uart4rcpkg.busy==1) WDTRST;    
 359   1         uart4rcpkg.busy=1;
 360   1         S4BUF=addrsum;
 361   1         
 362   1      }
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 7   

 363          
 364          
 365          void DoUart4CmdPro(void)
 366          {
 367   1      if (usbCmdCode==0x80)  //write
 368   1        {
 369   2          if (usbWRAddr==0x10)
 370   2          {
 371   3          if (usbWRData==0) usbWRData=1;
 372   3          else if (usbWRData>4) usbWRData=4;
 373   3          if (SaveLedData0.LedALLChanels!=usbWRData)
 374   3            {
 375   4              SaveLedData0.LedALLChanels=usbWRData;
 376   4              NeedSaveData=1;  //需要保存
 377   4              SaveLedData0.SelectedLedChanel=1;
 378   4              WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 379   4              if (LCD_DISPiD==1)
 380   4              {
 381   5                LCD_DrawWorkScreen();
 382   5              } 
 383   4              else 
 384   4              {
 385   5                DispSettingNumber(2,SaveLedData0.LedALLChanels);
 386   5              }
 387   4              SaveLedData0.Saveed=0;
 388   4            }
 389   3          }
 390   2          else if (usbWRAddr==0x11)
 391   2          {
 392   3            if (usbWRData==0) usbWRData=1; 
 393   3            else if (usbWRData>4) usbWRData=4;
 394   3            if (SaveLedData0.SelectedLedChanel!=usbWRData)
 395   3              {
 396   4              if (LCD_DISPiD==1)
 397   4                {
 398   5                UpdateSelcetedLed(usbWRData);
 399   5                }
 400   4              else 
 401   4                {
 402   5                SaveLedData0.SelectedLedChanel=usbWRData;
 403   5                }
 404   4              WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 405   4              SaveLedData0.Saveed=0;
 406   4              }
 407   3          }
 408   2          else if (usbWRAddr==0x12)
 409   2          {
 410   3            if (usbWRData>1) usbWRData=1;
 411   3            
 412   3            if (SaveLedData0.LedOnOff!=usbWRData)
 413   3              {
 414   4              if (LCD_DISPiD==1)
 415   4                {
 416   5                UpdateSelectedLedOnOff(usbWRData);
 417   5                }
 418   4              else 
 419   4                {
 420   5                SaveLedData0.LedOnOff=usbWRData;
 421   5                }
 422   4              WriteDriverAddressValue(0X12,SaveLedData0.LedOnOff);
 423   4              SaveLedData0.Saveed=0;
 424   4              }
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 8   

 425   3          }
 426   2          else if (usbWRAddr>=0x14 && usbWRAddr<=0x17)
 427   2          {
 428   3            if (usbWRData>100) usbWRData=100;
 429   3            if (SaveLedData0.LedPower[usbWRAddr-0x13]!=usbWRData)
 430   3              {
 431   4              SaveLedData0.LedPower[usbWRAddr-0x13]=usbWRData;
 432   4              if (LCD_DISPiD==1)
 433   4                {
 434   5                UpdateLcdPowerDisplay(usbWRAddr-0x13,usbWRData,SaveLedData0.LedOnOff);
 435   5                }
 436   4              WriteDriverAddressValue(usbWRAddr,usbWRData);
 437   4              SaveLedData0.Saveed=0;
 438   4              }
 439   3          }
 440   2          else if (usbWRAddr>=0x19 && usbWRAddr<=0x1c)
 441   2          {
 442   3            if (SaveLedData0.LEDMotorLocation[usbWRAddr-0x18]!=usbWRData)
 443   3              {
 444   4              SaveLedData0.LEDMotorLocation[usbWRAddr-0x18]=usbWRData;
 445   4              if (LCD_DISPiD>1)
 446   4                {
 447   5                DispSettingNumber((usbWRAddr-0x19)+4,usbWRData);
 448   5                }
 449   4              WriteDriverAddressValue(usbWRAddr,usbWRData);
 450   4              SaveLedData0.Saveed=0;
 451   4              }
 452   3          }
 453   2          else if (usbWRAddr==0x1d)
 454   2          {
 455   3            if (SaveLedData0.MotorStepPluses!=usbWRData)
 456   3              {
 457   4              SaveLedData0.MotorStepPluses=usbWRData;
 458   4              if (LCD_DISPiD>1)
 459   4                {
 460   5                DispSettingNumber(3,SaveLedData0.MotorStepPluses);
 461   5                }
 462   4              WriteDriverAddressValue(0X1d,usbWRData);
 463   4              SaveLedData0.Saveed=0;
 464   4              }
 465   3          }
 466   2        }
 467   1      else  if (uart4rcpkg.pic_N==0x81)  //read
 468   1        {
 469   2        if (usbWRAddr==0x10)
 470   2          {
 471   3          usbWRData=SaveLedData0.LedALLChanels;
 472   3          }
 473   2          else if (usbWRAddr==0x11)
 474   2          {
 475   3          usbWRData=SaveLedData0.SelectedLedChanel;
 476   3          }
 477   2          else if (usbWRAddr==0x12)
 478   2          {
 479   3          usbWRData=SaveLedData0.LedOnOff;
 480   3          }
 481   2          else if (usbWRAddr>=0x14 && usbWRAddr<=0x17)
 482   2          {
 483   3          usbWRData=SaveLedData0.LedPower[usbWRAddr-0x13];
 484   3          }
 485   2          else if (usbWRAddr>=0x19 && usbWRAddr<=0x1c)
 486   2          {
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 9   

 487   3          usbWRData=SaveLedData0.LEDMotorLocation[usbWRAddr-0x18];
 488   3          }
 489   2          else if (usbWRAddr==0x1d)
 490   2          {
 491   3          usbWRData=SaveLedData0.MotorStepPluses;
 492   3          }
 493   2        }
 494   1      
 495   1        ReturnWrUart4CmdUsb(usbWRAddr,usbWRData);
 496   1      }
 497          
 498          
 499          void HandleLCD(void)
 500          {
 501   1      static u8 ReadBytest=0;
 502   1        if (NeedUpdateLEDValue)
 503   1          {
 504   2          NeedUpdateLEDValue=0;
 505   2          GetDriverBoardReturn=0;
 506   2          if (ReadBytest==0)
 507   2            {
 508   3            ReadDriverAddressValue(0x10,1); //心跳包
 509   3            ReadBytest=1;
 510   3            }
 511   2          else if (ReadBytest==1)
 512   2            {
 513   3            ReadDriverAddressValue(0x11,1); //心跳包
 514   3            ReadBytest=2;
 515   3            }
 516   2          else
 517   2            {
 518   3            ReadDriverAddressValue(0x12,1); //心跳包
 519   3            ReadBytest=0;
 520   3            }
 521   2          }
 522   1        
 523   1        if (NeedUpdateConnect)
 524   1          {
 525   2          NeedUpdateConnect=0;
 526   2          WriteDriverSqAddressValue(0X10,&(SaveLedData0.DriverType),sizeof(Run_PARAMS));
 527   2          InitLcd();
 528   2          Beep();
 529   2          }
 530   1      
 531   1        if (NeedSaveData)
 532   1          {
 533   2          NeedSaveData=0;
 534   2          SaveLedData0.Saveed=1;
 535   2          WriteEEpromSaveData();
 536   2          }
 537   1      
 538   1        if (AutoOnLedCh)//自动
 539   1        {
 540   2          AutoOnLedCh=0;
 541   2          if (LCD_DISPiD==1 && SaveLedData0.LedOnOff==0)
 542   2            {
 543   3            UpdateSelectedLedOnOff(1); 
 544   3            WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 545   3            }
 546   2        }
 547   1      }
 548          
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 10  

 549          
 550          void DoRsUart2Cmd(void)
 551          {
 552   1        u8 i=0;
 553   1        u8 addrecode=uart2rcpkg.UartRunBuf[0];
 554   1        u8 datalen=uart2rcpkg.pklen-1;
 555   1        DriverBoardNoReplyCounter=0;
 556   1        GetDriverBoardReturn=1;
 557   1        if (DriverBoardConnetStatus==0)
 558   1          {
 559   2          DriverBoardConnetStatus=1;
 560   2          NeedUpdateConnect=1;
 561   2          }
 562   1      
 563   1        if (addrecode==0x10)  
 564   1          {
 565   2            if (SaveLedData0.DriverType!=uart2rcpkg.UartRunBuf[1])
 566   2              {
 567   3              WriteDriverAddressValue(0X10,SaveLedData0.DriverType);
 568   3              }
 569   2          }
 570   1        else if (addrecode==0x11) 
 571   1          {
 572   2          if (SaveLedData0.SelectedLedChanel!=uart2rcpkg.UartRunBuf[1])
 573   2            {
 574   3            if (LCD_DISPiD==1)
 575   3              {
 576   4              /*
 577   4              if (SaveLedData0.DriverType==0)
 578   4                {
 579   4                UpdateSelcetedLed(uart2rcpkg.UartRunBuf[1]);
 580   4                }
 581   4              else*/
 582   4                {
 583   5                WriteDriverAddressValue(0X11,SaveLedData0.SelectedLedChanel);
 584   5                }
 585   4              }
 586   3            }
 587   2          }
 588   1        else if (addrecode==0x12)
 589   1      
 590   1          {
 591   2          if (SaveLedData0.LedOnOff!=uart2rcpkg.UartRunBuf[1])
 592   2            {
 593   3            WriteDriverAddressValue(0X12,SaveLedData0.LedOnOff);
 594   3            }
 595   2          }
 596   1      }
 597          
 598          
 599          u8 DoUart2Pkg(void)
 600          {
 601   1        u8 temp;
 602   1        
 603   1        if (uart2Memory.RxByteSize==0) return 0;
 604   1      
 605   1        temp=uart2Memory.RxBuffer[uart2Memory.ReadCounter];
 606   1        if (uart2Memory.ReadCounter<(RxBufferSize-1)) uart2Memory.ReadCounter++; else uart2Memory.ReadCounter=0;
 607   1        if(uart2Memory.RxByteSize>0)   uart2Memory.RxByteSize--;
 608   1        switch (uart2rcpkg.RecStatus)
 609   1        {
 610   2          case REC_HEAD1:
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 11  

 611   2            if (temp==0X5A) uart2rcpkg.RecStatus=REC_HEAD2;
 612   2          break;
 613   2          case REC_HEAD2:
 614   2            if (temp==0XA5) uart2rcpkg.RecStatus=REC_RKLEN;
 615   2            else uart2rcpkg.RecStatus=REC_HEAD1;
 616   2          break;
 617   2          case REC_RKLEN:
 618   2          if (temp>24|| temp<1) 
 619   2              uart2rcpkg.RecStatus=REC_HEAD1;
 620   2            else 
 621   2              {
 622   3              uart2rcpkg.pklen=(uint8_t)(temp-1);
 623   3              uart2rcpkg.RecStatus=REC_CMD;
 624   3              }
 625   2          break;
 626   2          case REC_CMD:
 627   2            if (temp!=0x82)
 628   2              uart2rcpkg.RecStatus=REC_HEAD1;
 629   2            else 
 630   2              {
 631   3              uart2rcpkg.cmd=temp;
 632   3              uart2rcpkg.bufwpoint=0;
 633   3              uart2rcpkg.RecStatus=REC_DATA;
 634   3              }
 635   2            
 636   2          break;
 637   2          case REC_DATA:
 638   2            uart2rcpkg.UartRunBuf[uart2rcpkg.bufwpoint]=temp;
 639   2            uart2rcpkg.bufwpoint++;
 640   2            if (uart2rcpkg.bufwpoint>=uart2rcpkg.pklen)
 641   2              {
 642   3                DoRsUart2Cmd();
 643   3                uart2rcpkg.RecStatus=REC_HEAD1;
 644   3                return 1;
 645   3              }
 646   2          break;
 647   2          
 648   2        }
 649   1        return 2;
 650   1      }
 651          
 652          void CheckButton(void)
 653          {
 654   1        u8 tpv;
 655   1        u16 timout=0;
 656   1        u8 n1=0,n2=0;
 657   1        if (GetDriverBoardReturn==0) return;
 658   1      
 659   1        if (ABEncoderDir==1)
 660   1        {
 661   2          ABEncoderDir=0;
 662   2          if (LCD_DISPiD==1)
 663   2          {
 664   3            if (SaveLedData0.LedOnOff==1)
 665   3            {
 666   4              tpv=SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel];
 667   4              if (tpv<(100-ABEncoderAAC)) tpv+=ABEncoderAAC; else tpv=100;
 668   4              ABEncoderACCCounter=0;
 669   4              if (ABEncoderAAC<10) ABEncoderAAC++;
 670   4              SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel]=tpv;
 671   4              SaveLedData0.Saveed=0;
 672   4              UpdateLcdPowerDisplay(SaveLedData0.SelectedLedChanel,tpv,1);
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 12  

 673   4              WriteDriverAddressValue(0x13+SaveLedData0.SelectedLedChanel,tpv);
 674   4            }
 675   3            else 
 676   3            { 
 677   4              SelectChDelayCounter=0;
 678   4              tpv=SaveLedData0.SelectedLedChanel;
 679   4              UpdateLCDLEDSelected(tpv,0);
 680   4              if (tpv<(SaveLedData0.LedALLChanels)) tpv++; else tpv=1;
 681   4              SaveLedData0.SelectedLedChanel=tpv;
 682   4              UpdateLCDLEDSelected(tpv,1);
 683   4              MovetoOtherLedch=1;
 684   4            }
 685   3          }
 686   2          else 
 687   2          {
 688   3            if (LCD_DISPiD==2)
 689   3            {
 690   4              if (SaveLedData0.LedALLChanels<4) SaveLedData0.LedALLChanels++; 
 691   4              DispSettingNumber(LCD_DISPiD,SaveLedData0.LedALLChanels);
 692   4              SaveLedData0.SelectedLedChanel=1;
 693   4            }
 694   3            else if (LCD_DISPiD==3)
 695   3            {
 696   4              tpv=SaveLedData0.MotorStepPluses;
 697   4              if (tpv<(255-ABEncoderAAC)) tpv+=ABEncoderAAC; else tpv=255;
 698   4              SaveLedData0.MotorStepPluses=tpv;
 699   4              ABEncoderACCCounter=0;
 700   4              if (ABEncoderAAC<10) ABEncoderAAC++;
 701   4              DispSettingNumber(LCD_DISPiD,tpv);
 702   4              WriteDriverAddressValue(0X1d,tpv);
 703   4            }
 704   3            
 705   3            else if (LCD_DISPiD>3 && LCD_DISPiD<=7)
 706   3            {
 707   4              tpv=SaveLedData0.LEDMotorLocation[LCD_DISPiD-3];
 708   4              if (tpv<254) tpv+=1; else tpv=255;
 709   4              //if (tpv<(255-ABEncoderAAC)) tpv+=ABEncoderAAC; else tpv=255;
 710   4              //ABEncoderACCCounter=0;
 711   4              //if (ABEncoderAAC<10) ABEncoderAAC++;
 712   4              SaveLedData0.LEDMotorLocation[LCD_DISPiD-3]=tpv;
 713   4              DispSettingNumber(LCD_DISPiD,tpv);
 714   4              WriteDriverAddressValue(0X16+LCD_DISPiD-1,tpv);
 715   4              WriteDriverAddressValue2(0X11,LCD_DISPiD-3,1); //选择LED，点亮LED
 716   4            }
 717   3            else if (LCD_DISPiD==8)
 718   3            {
 719   4              SaveLedData0.DriverFanOnOff=1;
 720   4              DispSettingNumber(2,1);
 721   4              WriteDriverAddressValue(0X1e,1);
 722   4            }
 723   3            
 724   3             else if (LCD_DISPiD==9)
 725   3            {
 726   4              SaveLedData0.PurpleLamp=1;
 727   4              DispSettingNumber(3,1);
 728   4              WriteDriverAddressValue(0X20,1);
 729   4            }
 730   3            
 731   3          }
 732   2      
 733   2        }
 734   1        
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 13  

 735   1        else if (ABEncoderDir==0xff)
 736   1        {
 737   2          ABEncoderDir=0;
 738   2          if (LCD_DISPiD==1)
 739   2          {
 740   3            
 741   3            if (SaveLedData0.LedOnOff==1)
 742   3            {
 743   4              tpv=SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel];
 744   4              if (tpv>ABEncoderAAC) tpv-=ABEncoderAAC; else tpv=1;
 745   4              ABEncoderACCCounter=0;
 746   4              if (ABEncoderAAC<10) ABEncoderAAC++;
 747   4              SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel]=tpv;
 748   4              SaveLedData0.Saveed=0;
 749   4              UpdateLcdPowerDisplay(SaveLedData0.SelectedLedChanel,tpv,1);
 750   4              WriteDriverAddressValue(0x13+SaveLedData0.SelectedLedChanel,tpv);
 751   4            }
 752   3            else 
 753   3            {
 754   4              SelectChDelayCounter=0;
 755   4              tpv=SaveLedData0.SelectedLedChanel;
 756   4              UpdateLCDLEDSelected(tpv,0);
 757   4              if (tpv>1) tpv--; else tpv=SaveLedData0.LedALLChanels;
 758   4              SaveLedData0.SelectedLedChanel=tpv;
 759   4              UpdateLCDLEDSelected(tpv,1);
 760   4              MovetoOtherLedch=1;
 761   4            }
 762   3          }
 763   2          else 
 764   2          {
 765   3            if (LCD_DISPiD==2)
 766   3            {
 767   4              if (SaveLedData0.LedALLChanels>1) SaveLedData0.LedALLChanels--; 
 768   4              DispSettingNumber(LCD_DISPiD,SaveLedData0.LedALLChanels);
 769   4            }
 770   3            else if (LCD_DISPiD==3)
 771   3            {
 772   4              tpv=SaveLedData0.MotorStepPluses;
 773   4          
 774   4              if (tpv>(ABEncoderAAC+1)) tpv-=ABEncoderAAC; else tpv=1;
 775   4              SaveLedData0.MotorStepPluses=tpv;
 776   4              ABEncoderACCCounter=0;
 777   4              if (ABEncoderAAC<10) ABEncoderAAC++;
 778   4              DispSettingNumber(LCD_DISPiD,tpv);
 779   4              WriteDriverAddressValue(0X1d,tpv);  //设置LED 每步脉冲
 780   4            }
 781   3            else if (LCD_DISPiD>3 && LCD_DISPiD<=7)
 782   3            {
 783   4              tpv=SaveLedData0.LEDMotorLocation[LCD_DISPiD-3];
 784   4              if (tpv>0) tpv-=1; else tpv=0;
 785   4            //  if (tpv>ABEncoderAAC) tpv-=ABEncoderAAC; else tpv=0;
 786   4            //  ABEncoderACCCounter=0;
 787   4            //  if (ABEncoderAAC<10) ABEncoderAAC++;
 788   4              SaveLedData0.LEDMotorLocation[LCD_DISPiD-3]=tpv;
 789   4              DispSettingNumber(LCD_DISPiD,tpv);
 790   4              WriteDriverAddressValue(0X16+LCD_DISPiD-1,tpv);//发送led 位置信息
 791   4              WriteDriverAddressValue2(0X11,LCD_DISPiD-3,1);//发送选择的led 和 开灯
 792   4          
 793   4            }
 794   3            else if (LCD_DISPiD==8)
 795   3            {
 796   4              SaveLedData0.DriverFanOnOff=0;
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 14  

 797   4              DispSettingNumber(2,0);
 798   4              WriteDriverAddressValue(0X1e,0);
 799   4            }
 800   3            
 801   3              else if (LCD_DISPiD==9)
 802   3            {
 803   4              SaveLedData0.PurpleLamp=0;
 804   4              DispSettingNumber(3,0);
 805   4              WriteDriverAddressValue(0X20,0);
 806   4            }
 807   3            
 808   3          }
 809   2        }
 810   1      
 811   1        if (P32==0)//编码器按键
 812   1          {
 813   2          delay_ms(5);
 814   2          if (P32==0)
 815   2          {
 816   3          /*
 817   3            for (tpv=0;tpv<100;tpv++)
 818   3              {
 819   3              delay_ms(30);
 820   3              if (P32==1) break;
 821   3              }
 822   3            if(P32==0)
 823   3              {
 824   3              DisplaySetting();
 825   3              Beep();  //进入设置界面
 826   3              }
 827   3            else*/
 828   3              {
 829   4              Beep();
 830   4              if (LCD_DISPiD==1)// && GetDriverBoardReturn==1)
 831   4                {
 832   5                if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
 833   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 834   5                }
 835   4              else if (LCD_DISPiD>=2)
 836   4                {
 837   5                LCD_DISPiD++; 
 838   5                if (LCD_DISPiD==3) 
 839   5                  {
 840   6                  DispSettingRectangle();
 841   6                  WriteDriverAddressValue(0X1d,SaveLedData0.MotorStepPluses);  //设置LED 每步脉冲
 842   6                  }
 843   5                else if (LCD_DISPiD<=7) 
 844   5                  {
 845   6                  DispSettingRectangle();
 846   6                  WriteDriverAddressValue2(0X11,LCD_DISPiD-3,1);// update led selection and on off
 847   6                  }
 848   5                else if (LCD_DISPiD==8) //driver fan onoff
 849   5                  {
 850   6                    DisplaySetting1();              
 851   6                  }
 852   5                  else if(LCD_DISPiD==9)
 853   5                  {
 854   6                    DisplaySetting2();
 855   6                  }
 856   5                else 
 857   5                  {
 858   6                  LCD_DISPiD=1;
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 15  

 859   6                  LCD_DrawWorkScreen();
 860   6                  NeedSaveData=1;  //需要保存
 861   6                  WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 862   6                  }
 863   5                
 864   5                }
 865   4              }
 866   3      
 867   3            while (P32==0) 
 868   3              {
 869   4              WDTRST;
 870   4              while (P32==0)  delay_ms(5);
 871   4              }
 872   3          }
 873   2        }
 874   1      
 875   1      
 876   1      /*
 877   1        
 878   1        if (ABEncoderDir==1)
 879   1        {
 880   1          ABEncoderDir=2;
 881   1          
 882   1        }
 883   1        else if (ABEncoderDir==0xff)
 884   1        {
 885   1          ABEncoderDir=2;
 886   1          
 887   1        }
 888   1         */
 889   1      
 890   1      //   ABEncoderStep=;
 891   1         if ((P3&0X88)==0x88) ABEncoderDir=0;
 892   1      
 893   1      
 894   1        
 895   1      
 896   1        if (P26==0)
 897   1        {
 898   2          delay_ms(5);
 899   2          if (P26==0)
 900   2          {
 901   3            Beep();
 902   3              if (LCD_DISPiD==1)
 903   3               {
 904   4                if (SaveLedData0.SelectedLedChanel==1)
 905   4                {
 906   5                  if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
 907   5                  WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 908   5                }
 909   4                else
 910   4                {
 911   5                  UpdateSelcetedLed(1);
 912   5                  UpdateSelectedLedOnOff(1); 
 913   5                  WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 914   5                }
 915   4               }
 916   3            
 917   3              while (P26==0) 
 918   3              {
 919   4              WDTRST;
 920   4              while (P26==0)  
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 16  

 921   4                {
 922   5                
 923   5                if (P01==0)
 924   5                  {
 925   6                  for (tpv=0;tpv<100;tpv++)
 926   6                  {
 927   7                    delay_ms(30);
 928   7                    if (P26!=0 || P01!=0) break;
 929   7                    }
 930   6                    if (P26==0 && P01==0)
 931   6                      {
 932   7                      DisplaySetting();
 933   7                      Beep();  //进入设置界面
 934   7                      }
 935   6                    while (P26==0 || P01==0) 
 936   6                    {
 937   7                    WDTRST;
 938   7                    while (P26==0 || P01==0)  delay_ms(5);
 939   7                  }
 940   6                  }
 941   5                else 
 942   5                  delay_ms(5);
 943   5                }
 944   4              }
 945   3            }
 946   2        }
 947   1        
 948   1        if (P27==0)
 949   1        {
 950   2          delay_ms(5);
 951   2          if (P27==0)
 952   2          {
 953   3            Beep();
 954   3            if (LCD_DISPiD==1)
 955   3             {
 956   4              if (SaveLedData0.SelectedLedChanel==2)
 957   4              {
 958   5                if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
 959   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 960   5              }
 961   4              else  if (SaveLedData0.LedALLChanels>1)
 962   4              {
 963   5                UpdateSelcetedLed(2);
 964   5                UpdateSelectedLedOnOff(1); 
 965   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 966   5              }
 967   4      
 968   4            }
 969   3            while (P27==0) 
 970   3              {
 971   4              WDTRST;
 972   4              while (P27==0)  delay_ms(5);
 973   4              }
 974   3          }
 975   2        }
 976   1      
 977   1        if (P00==0)
 978   1        {
 979   2          delay_ms(5);
 980   2          if (P00==0)
 981   2          {
 982   3            Beep();
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 17  

 983   3            if (LCD_DISPiD==1)
 984   3            {
 985   4              if (SaveLedData0.SelectedLedChanel==3)
 986   4              {
 987   5                if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
 988   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 989   5              }
 990   4              else if (SaveLedData0.LedALLChanels>2)
 991   4              {
 992   5                UpdateSelcetedLed(3);
 993   5                UpdateSelectedLedOnOff(1); 
 994   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 995   5              }
 996   4            }
 997   3            while (P00==0) 
 998   3              {
 999   4              WDTRST;
1000   4              while (P00==0)  delay_ms(5);
1001   4              }
1002   3          }
1003   2        }
1004   1      
1005   1        if (P01==0)
1006   1        {
1007   2          delay_ms(5);
1008   2          if (P01==0)
1009   2          {
1010   3            Beep();
1011   3            
1012   3            if (LCD_DISPiD==1)
1013   3            {
1014   4              if (SaveLedData0.SelectedLedChanel==4)
1015   4              {
1016   5                if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
1017   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
1018   5              }
1019   4              else if (SaveLedData0.LedALLChanels>3)
1020   4              {
1021   5                UpdateSelcetedLed(4);
1022   5                UpdateSelectedLedOnOff(1); 
1023   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
1024   5              }
1025   4            }
1026   3            while (P01==0) 
1027   3              {
1028   4              WDTRST;
1029   4              while (P01==0) 
1030   4                {
1031   5                if (P26==0)
1032   5                  {
1033   6                  for (tpv=0;tpv<100;tpv++)
1034   6                  {
1035   7                  delay_ms(30);
1036   7                  if (P26!=0 || P01!=0) break;
1037   7                  }
1038   6                  if (P26==0 && P01==0)
1039   6                    {
1040   7                    DisplaySetting();
1041   7                    Beep();  //进入设置界面
1042   7                    }
1043   6                  while (P26==0 || P01==0) 
1044   6                    {
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 18  

1045   7                    WDTRST;
1046   7                    while (P26==0 || P01==0)  delay_ms(5);
1047   7                    }
1048   6                  }
1049   5                else 
1050   5                  delay_ms(5);
1051   5                }
1052   4              }
1053   3          }
1054   2        }
1055   1      
1056   1      
1057   1        if (UsbCmdUpdate!=0)
1058   1        {
1059   2          UsbCmdUpdate=0;
1060   2          DoUart4CmdPro();
1061   2        }
1062   1      }
1063          
1064          void ExClockConfig(void)
1065          {
1066   1      // u32 timeoutcounter=0;
1067   1        P_SW2 = 0x80;
1068   1        XOSCCR = 0xc0;                //???ˉía2??§??
1069   1        while (!(XOSCCR & 1) ) 
1070   1          {
1071   2          WDTRST;        //μè′yê±?ó?è?¨
1072   2          }
1073   1        CLKDIV = 0x00;                 //ê±?ó2?・??μ
1074   1        CKSEL = 0x01;               //????ía2??§??
1075   1        P_SW2 = 0x00;
1076   1      }
1077          
1078          
1079          void main()
1080          {
1081   1        
1082   1        ExClockConfig();
1083   1        if(CmpDataFlashUuid()==0) while (1);
1084   1        Gpio_Init();
1085   1        Uart2Init();   //DRIVER BOARD
1086   1        Uart4Init();  //USB
1087   1        lcd_initial();
1088   1        Timer0Init();
1089   1        SPI_FLASH_Init();
1090   1        delay_ms(100);
1091   1        Gui_DrawFlashbmp16(0,0,0);
1092   1      //  
1093   1      //  Display_ASCII8X16(50,16,"EasyLWL",7,BLUE);
1094   1        CtrlLcdBL(1);
1095   1        EA=1;
1096   1        ReadDriverAddressValue(0x10,1);
1097   1        Beep();
1098   1        ReadEEpromSaveData();
1099   1        ReadDriverAddressValue(0x10,1);
1100   1      
1101   1        //开机加载画
1102   1        while (StartDelayCounter<MAXSTARTDELAYTIME)  //等待开机停留时间, lcd 应答
1103   1          {
1104   2          WDTRST;  
1105   2          if ((StartDelayCounter>=MINSTARTDELAYTIME) &&(GetDriverBoardReturn!=0)) break;
1106   2          if (NeedUpdateLEDValue)
C51 COMPILER V9.59.0.0   MAIN                                                              03/30/2024 01:43:46 PAGE 19  

1107   2          {
1108   3          NeedUpdateLEDValue=0;
1109   3          GetDriverBoardReturn=0;
1110   3          ReadDriverAddressValue(0x10,1); //心跳包
1111   3          }
1112   2          DoUart2Pkg();  //driver board
1113   2          }
1114   1        
1115   1        NeedUpdateConnect=0;
1116   1        InitLcd();
1117   1        WriteDriverSqAddressValue(0X10,&(SaveLedData0.DriverType),sizeof(Run_PARAMS));
1118   1        /* Infinite loop */
1119   1        while (1)
1120   1        {
1121   2          WDTRST;                      //清看门狗,否则系统复位
1122   2          DoUart2Pkg();  //driver board
1123   2          //DoUart4Pkg();   //usb uart4 interrupt sub run 
1124   2        CheckButton();
1125   2        HandleLCD();
1126   2        }
1127   1      }
1128          
1129          
1130          
1131          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5964    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    348    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
