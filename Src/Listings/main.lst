C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OMF2 OPTIMIZE(0,SIZE) BROWSE ORDER INCDIR(..\Src;.\LCD) DEB
                    -UG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file    Project/main.c 
   4            * @author  MCD Application Team
   5            * @version V2.2.0
   6            * @date    30-September-2014
   7            * @brief   Main program body
   8           */
   9          /* Includes ------------------------------------------------------------------*/
  10          #include "main.h"
  11          #include "lcd.h"
  12          #include "ABencoder.h"
  13          #include "uarttask.h"
  14          #include "spi_flash.h"
  15          #include "eeprom.h"
  16          #include "SaveConfigfile.h"
  17          #include "uuid.h"
  18          /* Private defines -----------------------------------------------------------*/
  19          
  20          #define NOREPLSYTIMES 5
  21          #define MAXSTARTDELAYTIME 10
  22          #define MINSTARTDELAYTIME 3
  23          
  24          
  25          #define EX2             0x10
  26          #define EX3             0x20
  27          #define EX4             0x40
  28          
  29          
  30          sbit LED = P2^1;
  31          
  32          /* Private function prototypes -----------------------------------------------*/
  33          /* Private functions ---------------------------------------------------------*/
  34          void InitLcd(void);
  35          
  36           
  37           
  38          u8 UsbCmdUpdate=0;
  39          u8 usbCmdCode=0;
  40          u8 usbWRAddr,usbWRData;
  41          //UARTST_PKG  uart1rcpkg;
  42          UARTST_PKG uart2rcpkg;
  43          //UARTST_PKG uart3rcpkg;
  44          UARTST4_PKG uart4rcpkg;
  45          
  46          uint8_t LCD_DISPiD=0;
  47          uint8_t NeedUpdateLEDValue=0,NeedUpdateConnect=0,NeedSaveData=0;
  48          
  49          u8 DriverBoardConnetStatus=0;
  50          u8 DriverBoardNoReplyCounter=0;
  51          u8 LedShareCounter=0;
  52          u8 SelectData=0;
  53          u8 UpdateTHCounter=0;
  54          u8 RunModel=0;
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 2   

  55          u8 StartDelayCounter=0;
  56          u8 SaveEEpromDelaycounter=0;
  57          u8 Temperature=0,Humidity=0;
  58          u8 GetDriverBoardReturn=0;
  59          
  60          u8 ABEncoderACCCounter=0;
  61          u8 ABEncoderAAC=1;
  62          
  63          
  64          u8 SelectChDelayCounter=0;
  65          u8 AutoOnLedCh=0;
  66          u8 MovetoOtherLedch=0;
  67          
  68          void delay_us(uint16_t dt) 
  69          {
  70   1        dt = dt<<1;
  71   1        while (--dt) WDTRST;
  72   1      }
  73            
  74          
  75          
  76          void delay_ms(uint16_t dt)
  77          {
  78   1       while (dt>0)
  79   1        {
  80   2        delay_us(400);
  81   2        dt--;
  82   2        }
  83   1      }
  84          
  85          void ClearMemory(uint8_t * ptr,uint8_t len)
  86          {
  87   1        uint8_t i;
  88   1         for (i=0;i<len;i++)  
  89   1          {
  90   2          *ptr=0;
  91   2          ptr++;
  92   2          }
  93   1      }
  94          
  95          void SetMemory(uint8_t * ptr,uint8_t len)
  96          {
  97   1        uint8_t i;
  98   1         for (i=0;i<len;i++)  
  99   1          {
 100   2          *ptr=0xff;
 101   2          ptr++;
 102   2          }
 103   1      }
 104          
 105          void Memcpy2(u8* src, u8* dec,u8 len)
 106          {
 107   1        uint8_t i;
 108   1         for (i=0;i<len;i++)  
 109   1          {
 110   2          *dec=*src;
 111   2          src++;
 112   2          dec++;
 113   2          }
 114   1      }
 115          
 116          u8 cmpMemory(u8* ptr, u8* dec ,u8 len)
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 3   

 117          {
 118   1        uint8_t i;
 119   1         for (i=0;i<len;i++)  
 120   1          {
 121   2          if ((*dec)!=(*ptr)) return 0;
 122   2          ptr++;
 123   2          dec++;
 124   2          }
 125   1         return 1;
 126   1      }
 127          
 128          
 129          
 130          
 131          
 132          void Gpio_Init(void)
 133          {
 134   1        
 135   1        P26=1; P27=1;P00=1;P01=1; // 按键1-4
 136   1      
 137   1        
 138   1        P32=1;P33=1;P36=0;P37=1;//编码器输入
 139   1        P20=1; //speaker
 140   1        LED=0; //LED
 141   1        
 142   1        P0M0=0;
 143   1        P0M1=0;
 144   1        
 145   1        P1M0=0;
 146   1        P1M1=0;+
 147   1        
 148   1        P2M0=0x2E;
 149   1        P2M1=0;
 150   1      
 151   1        P3M0=0X40;
 152   1        P3M1=0;
 153   1      
 154   1        P5M0=0X10;
 155   1        P5M1=0;
 156   1      
 157   1        IT1 = 1;                                    //使能INT1 下降沿中断
 158   1          EX1 = 1;                                    //使能INT1中断
 159   1        INTCLKO = EX3;                              //使能INT3中断
 160   1      
 161   1      }
 162          
 163          void Beep(void)
 164          {
 165   1        P20=0;  //SPK
 166   1        delay_ms(100);
 167   1        P20=1;
 168   1      }
 169          
 170          void Timer0Init(void)   //20毫秒@33.1776MHz
 171          {
 172   1        AUXR &= 0x7F;   //定时器时钟12T模式
 173   1        TMOD &= 0xF0;   //设置定时器模式
 174   1        TL0 = 0x00;   //设置定时初值
 175   1        TH0 = 0x28;   //设置定时初值
 176   1        ET0 = 1;                                   
 177   1        TF0 = 0;    //清除TF0标志
 178   1        TR0 = 1;    //定时器0开始计时
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 4   

 179   1      }
 180          
 181          void UpdateSelectedLedOnOff(u8 nonoff)
 182          {
 183   1        if (nonoff==0) MovetoOtherLedch=0;
 184   1        SaveLedData0.LedOnOff=nonoff;
 185   1        UpdateLCDLEDCloum(SaveLedData0.SelectedLedChanel,SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel],Sa
             -veLedData0.LedOnOff);
 186   1      }
 187          
 188          
 189          void UpdateSelcetedLed(u8 newSelCh)
 190          {
 191   1      
 192   1        if (SaveLedData0.SelectedLedChanel!=newSelCh)
 193   1        {
 194   2          UpdateLCDLEDCloum(SaveLedData0.SelectedLedChanel,SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel],0
             -);
 195   2          UpdateLCDLEDSelected(SaveLedData0.SelectedLedChanel,0); 
 196   2          SaveLedData0.SelectedLedChanel=newSelCh;
 197   2          UpdateLCDLEDSelected(SaveLedData0.SelectedLedChanel,1); 
 198   2          UpdateSelectedLedOnOff(SaveLedData0.LedOnOff);
 199   2        }
 200   1      }
 201          
 202          
 203          
 204          //time0 定时超时判断
 205          void Time0OutDelaySub(void)
 206          {
 207   1      
 208   1        if (uart2rcpkg.RecStatus!=REC_HEAD1)
 209   1          {
 210   2          uart2Memory.UartPkgTimeoutCounter++;
 211   2          if (uart2Memory.UartPkgTimeoutCounter>50)
 212   2            {
 213   3            uart2Memory.UartPkgTimeoutCounter=0;
 214   3            uart2rcpkg.RecStatus=REC_HEAD1;
 215   3            }
 216   2          }
 217   1          
 218   1        if (uart4rcpkg.RecStatus!=REC2_HEAD1)
 219   1          {
 220   2          uart4rcpkg.UartPkgTimeoutCounter++;
 221   2          if (uart4rcpkg.UartPkgTimeoutCounter>50)
 222   2            {
 223   3            uart4rcpkg.UartPkgTimeoutCounter=0;
 224   3            uart4rcpkg.RecStatus=REC2_HEAD1;
 225   3            }
 226   2          }
 227   1      
 228   1        if (uart4rcpkg.UsbCmdStatus!=REC4_HEAD1)
 229   1          {
 230   2          uart4rcpkg.UartPkgTimeoutCounter++;
 231   2          if (uart4rcpkg.UartPkgTimeoutCounter>50)
 232   2            {
 233   3            uart4rcpkg.UartPkgTimeoutCounter=0;
 234   3            uart4rcpkg.UsbCmdStatus=REC4_HEAD1;
 235   3            }
 236   2          }
 237   1      
 238   1        if (SaveLedData0.Saveed==0 &&  ABEncoderDir==0) 
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 5   

 239   1          {
 240   2          if (SaveEEpromDelaycounter>=150)   //3秒
 241   2            {
 242   3            NeedSaveData=1;
 243   3            }
 244   2          else
 245   2            {
 246   3            SaveEEpromDelaycounter++;
 247   3            }
 248   2          }
 249   1        else 
 250   1          {
 251   2          SaveEEpromDelaycounter=0;
 252   2          }
 253   1        
 254   1      
 255   1        if (ABEncoderAAC!=1) ABEncoderACCCounter++;
 256   1      
 257   1        if (ABEncoderACCCounter>=15)
 258   1          {
 259   2          ABEncoderACCCounter=0;
 260   2          ABEncoderAAC=1;
 261   2          }
 262   1        
 263   1      
 264   1        if ((LCD_DISPiD==1) && (SaveLedData0.LedOnOff==0) && (MovetoOtherLedch==1)) SelectChDelayCounter++;//自动
 265   1          if(SaveLedData0.SelectedLedChanel==1&&SaveLedData0.PurpleLamp==0)
 266   1          {
 267   2          if (SelectChDelayCounter>75)  
 268   2          {
 269   3          SelectChDelayCounter=0;
 270   3          AutoOnLedCh=0;
 271   3          MovetoOtherLedch=0;
 272   3           }
 273   2          }
 274   1          else
 275   1          {
 276   2          if (SelectChDelayCounter>75)  
 277   2          {
 278   3          SelectChDelayCounter=0;
 279   3          AutoOnLedCh=1;
 280   3          MovetoOtherLedch=0;
 281   3           }
 282   2          }
 283   1        
 284   1      
 285   1        LedShareCounter++;
 286   1        if (LedShareCounter==25)   //0.5秒
 287   1          {
 288   2          LED=!LED;
 289   2          
 290   2          }
 291   1        else if (LedShareCounter>=50)  //1秒
 292   1          {
 293   2          LedShareCounter=0;
 294   2          NeedUpdateLEDValue=1;
 295   2          
 296   2          LED=!LED;
 297   2          if (StartDelayCounter<MAXSTARTDELAYTIME)  StartDelayCounter++;
 298   2          
 299   2        if (GetDriverBoardReturn==1) 
 300   2          {
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 6   

 301   3            DriverBoardNoReplyCounter=0;
 302   3            if (DriverBoardConnetStatus==0) NeedUpdateConnect=1;
 303   3            DriverBoardConnetStatus=1;
 304   3            
 305   3          }
 306   2        else 
 307   2          {
 308   3            if (DriverBoardConnetStatus==1) DriverBoardNoReplyCounter++;
 309   3            if (DriverBoardNoReplyCounter>NOREPLSYTIMES)  
 310   3              {
 311   4              DriverBoardNoReplyCounter=0;
 312   4              DriverBoardConnetStatus=0;
 313   4              NeedUpdateConnect=1;
 314   4              }
 315   3            //GetDriverBoardReturn=0;
 316   3          } 
 317   2          }
 318   1      }
 319          
 320          void InitLcd(void)
 321          {
 322   1        if (GetDriverBoardReturn==0)  //驱动板没有返回
 323   1          {
 324   2          DisplayDisconnect();
 325   2          }
 326   1        else 
 327   1          {
 328   2          LCD_DrawWorkScreen();
 329   2          }
 330   1      }
 331          
 332          
 333          
 334          
 335          
 336          void ReturnWrUart4CmdUsb(u8 Wraddr,u8 WrData)
 337          {
 338   1         u8 addrsum=0;
 339   1         
 340   1         while (uart4rcpkg.busy==1) WDTRST;    
 341   1         uart4rcpkg.busy=1;
 342   1         S4BUF=0x69;
 343   1         while (uart4rcpkg.busy==1) WDTRST;    
 344   1         uart4rcpkg.busy=1;
 345   1         S4BUF=0x96;
 346   1         while (uart4rcpkg.busy==1) WDTRST;    
 347   1         uart4rcpkg.busy=1;
 348   1         S4BUF=usbCmdCode;
 349   1         addrsum+=usbCmdCode;
 350   1          while (uart4rcpkg.busy==1) WDTRST;    
 351   1         uart4rcpkg.busy=1;
 352   1         S4BUF=Wraddr;
 353   1         addrsum+=Wraddr;
 354   1          while (uart4rcpkg.busy==1) WDTRST;    
 355   1         uart4rcpkg.busy=1;
 356   1         S4BUF=WrData;
 357   1         addrsum+=WrData;
 358   1         while (uart4rcpkg.busy==1) WDTRST;    
 359   1         uart4rcpkg.busy=1;
 360   1         S4BUF=addrsum;
 361   1         
 362   1      }
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 7   

 363          
 364          
 365          void DoUart4CmdPro(void)
 366          {
 367   1      if (usbCmdCode==0x80)  //write
 368   1        {
 369   2          if (usbWRAddr==0x10)
 370   2          {
 371   3          if (usbWRData==0) usbWRData=1;
 372   3          else if (usbWRData>4) usbWRData=4;
 373   3          if (SaveLedData0.LedALLChanels!=usbWRData)
 374   3            {
 375   4              SaveLedData0.LedALLChanels=usbWRData;
 376   4              NeedSaveData=1;  //需要保存
 377   4              SaveLedData0.SelectedLedChanel=1;
 378   4              WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 379   4              if (LCD_DISPiD==1)
 380   4              {
 381   5                LCD_DrawWorkScreen();
 382   5              } 
 383   4              else 
 384   4              {
 385   5                DispSettingNumber(2,SaveLedData0.LedALLChanels);
 386   5              }
 387   4              SaveLedData0.Saveed=0;
 388   4            }
 389   3          }
 390   2          else if (usbWRAddr==0x11)
 391   2          {
 392   3            if (usbWRData==0) usbWRData=1; 
 393   3            else if (usbWRData>4) usbWRData=4;
 394   3            if (SaveLedData0.SelectedLedChanel!=usbWRData)
 395   3              {
 396   4              if (LCD_DISPiD==1)
 397   4                {
 398   5                UpdateSelcetedLed(usbWRData);
 399   5                }
 400   4              else 
 401   4                {
 402   5                SaveLedData0.SelectedLedChanel=usbWRData;
 403   5                }
 404   4              WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 405   4              SaveLedData0.Saveed=0;
 406   4              }
 407   3          }
 408   2          else if (usbWRAddr==0x12)
 409   2          {
 410   3            if (usbWRData>1) usbWRData=1;
 411   3            
 412   3            if (SaveLedData0.LedOnOff!=usbWRData)
 413   3              {
 414   4              if (LCD_DISPiD==1)
 415   4                {
 416   5                UpdateSelectedLedOnOff(usbWRData);
 417   5                }
 418   4              else 
 419   4                {
 420   5                SaveLedData0.LedOnOff=usbWRData;
 421   5                }
 422   4              WriteDriverAddressValue(0X12,SaveLedData0.LedOnOff);
 423   4              SaveLedData0.Saveed=0;
 424   4              }
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 8   

 425   3          }
 426   2          else if (usbWRAddr>=0x14 && usbWRAddr<=0x17)
 427   2          {
 428   3            if (usbWRData>100) usbWRData=100;
 429   3            if (SaveLedData0.LedPower[usbWRAddr-0x13]!=usbWRData)
 430   3              {
 431   4              SaveLedData0.LedPower[usbWRAddr-0x13]=usbWRData;
 432   4              if (LCD_DISPiD==1)
 433   4                {
 434   5                UpdateLcdPowerDisplay(usbWRAddr-0x13,usbWRData,SaveLedData0.LedOnOff);
 435   5                }
 436   4              WriteDriverAddressValue(usbWRAddr,usbWRData);
 437   4              SaveLedData0.Saveed=0;
 438   4              }
 439   3          }
 440   2          else if (usbWRAddr>=0x19 && usbWRAddr<=0x1c)
 441   2          {
 442   3            if (SaveLedData0.LEDMotorLocation[usbWRAddr-0x18]!=usbWRData)
 443   3              {
 444   4              SaveLedData0.LEDMotorLocation[usbWRAddr-0x18]=usbWRData;
 445   4              if (LCD_DISPiD>1)
 446   4                {
 447   5                DispSettingNumber((usbWRAddr-0x19)+4,usbWRData);
 448   5                }
 449   4              WriteDriverAddressValue(usbWRAddr,usbWRData);
 450   4              SaveLedData0.Saveed=0;
 451   4              }
 452   3          }
 453   2          else if (usbWRAddr==0x1d)
 454   2          {
 455   3            if (SaveLedData0.MotorStepPluses!=usbWRData)
 456   3              {
 457   4              SaveLedData0.MotorStepPluses=usbWRData;
 458   4              if (LCD_DISPiD>1)
 459   4                {
 460   5                DispSettingNumber(3,SaveLedData0.MotorStepPluses);
 461   5                }
 462   4              WriteDriverAddressValue(0X1d,usbWRData);
 463   4              SaveLedData0.Saveed=0;
 464   4              }
 465   3          }
 466   2        }
 467   1      else  if (uart4rcpkg.pic_N==0x81)  //read
 468   1        {
 469   2        if (usbWRAddr==0x10)
 470   2          {
 471   3          usbWRData=SaveLedData0.LedALLChanels;
 472   3          }
 473   2          else if (usbWRAddr==0x11)
 474   2          {
 475   3          usbWRData=SaveLedData0.SelectedLedChanel;
 476   3          }
 477   2          else if (usbWRAddr==0x12)
 478   2          {
 479   3          usbWRData=SaveLedData0.LedOnOff;
 480   3          }
 481   2          else if (usbWRAddr>=0x14 && usbWRAddr<=0x17)
 482   2          {
 483   3          usbWRData=SaveLedData0.LedPower[usbWRAddr-0x13];
 484   3          }
 485   2          else if (usbWRAddr>=0x19 && usbWRAddr<=0x1c)
 486   2          {
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 9   

 487   3          usbWRData=SaveLedData0.LEDMotorLocation[usbWRAddr-0x18];
 488   3          }
 489   2          else if (usbWRAddr==0x1d)
 490   2          {
 491   3          usbWRData=SaveLedData0.MotorStepPluses;
 492   3          }
 493   2        }
 494   1      
 495   1        ReturnWrUart4CmdUsb(usbWRAddr,usbWRData);
 496   1      }
 497          
 498          
 499          void HandleLCD(void)
 500          {
 501   1      static u8 ReadBytest=0;
 502   1        if (NeedUpdateLEDValue)
 503   1          {
 504   2          NeedUpdateLEDValue=0;
 505   2          GetDriverBoardReturn=0;
 506   2          if (ReadBytest==0)
 507   2            {
 508   3            ReadDriverAddressValue(0x10,1); //心跳包
 509   3            ReadBytest=1;
 510   3            }
 511   2          else if (ReadBytest==1)
 512   2            {
 513   3            ReadDriverAddressValue(0x11,1); //心跳包
 514   3            ReadBytest=2;
 515   3            }
 516   2          else
 517   2            {
 518   3            ReadDriverAddressValue(0x12,1); //心跳包
 519   3            ReadBytest=0;
 520   3            }
 521   2          }
 522   1        
 523   1        if (NeedUpdateConnect)
 524   1          {
 525   2          NeedUpdateConnect=0;
 526   2          WriteDriverSqAddressValue(0X10,&(SaveLedData0.DriverType),sizeof(Run_PARAMS));
 527   2          InitLcd();
 528   2          Beep();
 529   2          }
 530   1      
 531   1        if (NeedSaveData)
 532   1          {
 533   2          NeedSaveData=0;
 534   2          SaveLedData0.Saveed=1;
 535   2          WriteEEpromSaveData();
 536   2          }
 537   1      
 538   1        if (AutoOnLedCh)//自动
 539   1        {
 540   2          AutoOnLedCh=0;
 541   2          if (LCD_DISPiD==1 && SaveLedData0.LedOnOff==0)
 542   2            {
 543   3            UpdateSelectedLedOnOff(1); 
 544   3            WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 545   3            }
 546   2        }
 547   1      }
 548          
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 10  

 549          
 550          void DoRsUart2Cmd(void)
 551          {
 552   1        u8 i=0;
 553   1        u8 addrecode=uart2rcpkg.UartRunBuf[0];
 554   1        u8 datalen=uart2rcpkg.pklen-1;
 555   1        DriverBoardNoReplyCounter=0;
 556   1        GetDriverBoardReturn=1;
 557   1        if (DriverBoardConnetStatus==0)
 558   1          {
 559   2          DriverBoardConnetStatus=1;
 560   2          NeedUpdateConnect=1;
 561   2          }
 562   1      
 563   1        if (addrecode==0x10)  
 564   1          {
 565   2            if (SaveLedData0.DriverType!=uart2rcpkg.UartRunBuf[1])
 566   2              {
 567   3              WriteDriverAddressValue(0X10,SaveLedData0.DriverType);
 568   3              }
 569   2          }
 570   1        else if (addrecode==0x11) 
 571   1          {
 572   2          if (SaveLedData0.SelectedLedChanel!=uart2rcpkg.UartRunBuf[1])
 573   2            {
 574   3            if (LCD_DISPiD==1)
 575   3              {
 576   4              /*
 577   4              if (SaveLedData0.DriverType==0)
 578   4                {
 579   4                UpdateSelcetedLed(uart2rcpkg.UartRunBuf[1]);
 580   4                }
 581   4              else*/
 582   4                {
 583   5                  if(MovetoOtherLedch!=1)           
 584   5                WriteDriverAddressValue(0X11,SaveLedData0.SelectedLedChanel);
 585   5                }
 586   4              }
 587   3            }
 588   2          }
 589   1        else if (addrecode==0x12)
 590   1      
 591   1          {
 592   2          if (SaveLedData0.LedOnOff!=uart2rcpkg.UartRunBuf[1])
 593   2            {
 594   3            WriteDriverAddressValue(0X12,SaveLedData0.LedOnOff);
 595   3            }
 596   2          }
 597   1      }
 598          
 599          
 600          u8 DoUart2Pkg(void)
 601          {
 602   1        u8 temp;
 603   1        
 604   1        if (uart2Memory.RxByteSize==0) return 0;
 605   1      
 606   1        temp=uart2Memory.RxBuffer[uart2Memory.ReadCounter];
 607   1        if (uart2Memory.ReadCounter<(RxBufferSize-1)) uart2Memory.ReadCounter++; else uart2Memory.ReadCounter=0;
 608   1        if(uart2Memory.RxByteSize>0)   uart2Memory.RxByteSize--;
 609   1        switch (uart2rcpkg.RecStatus)
 610   1        {
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 11  

 611   2          case REC_HEAD1:
 612   2            if (temp==0X5A) uart2rcpkg.RecStatus=REC_HEAD2;
 613   2          break;
 614   2          case REC_HEAD2:
 615   2            if (temp==0XA5) uart2rcpkg.RecStatus=REC_RKLEN;
 616   2            else uart2rcpkg.RecStatus=REC_HEAD1;
 617   2          break;
 618   2          case REC_RKLEN:
 619   2          if (temp>24|| temp<1) 
 620   2              uart2rcpkg.RecStatus=REC_HEAD1;
 621   2            else 
 622   2              {
 623   3              uart2rcpkg.pklen=(uint8_t)(temp-1);
 624   3              uart2rcpkg.RecStatus=REC_CMD;
 625   3              }
 626   2          break;
 627   2          case REC_CMD:
 628   2            if (temp!=0x82)
 629   2              uart2rcpkg.RecStatus=REC_HEAD1;
 630   2            else 
 631   2              {
 632   3              uart2rcpkg.cmd=temp;
 633   3              uart2rcpkg.bufwpoint=0;
 634   3              uart2rcpkg.RecStatus=REC_DATA;
 635   3              }
 636   2            
 637   2          break;
 638   2          case REC_DATA:
 639   2            uart2rcpkg.UartRunBuf[uart2rcpkg.bufwpoint]=temp;
 640   2            uart2rcpkg.bufwpoint++;
 641   2            if (uart2rcpkg.bufwpoint>=uart2rcpkg.pklen)
 642   2              {
 643   3                DoRsUart2Cmd();
 644   3                uart2rcpkg.RecStatus=REC_HEAD1;
 645   3                return 1;
 646   3              }
 647   2          break;
 648   2          
 649   2        }
 650   1        return 2;
 651   1      }
 652          
 653          void CheckButton(void)
 654          {
 655   1        u8 tpv;
 656   1        u16 timout=0;
 657   1        u8 n1=0,n2=0;
 658   1        if (GetDriverBoardReturn==0) return;
 659   1      
 660   1        if (ABEncoderDir==1)
 661   1        {
 662   2          ABEncoderDir=0;
 663   2          if (LCD_DISPiD==1)
 664   2          {
 665   3            if (SaveLedData0.LedOnOff==1)
 666   3            {
 667   4              tpv=SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel];
 668   4              if (tpv<(100-ABEncoderAAC)) tpv+=ABEncoderAAC; else tpv=100;
 669   4              ABEncoderACCCounter=0;
 670   4              if (ABEncoderAAC<10) ABEncoderAAC++;
 671   4              SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel]=tpv;
 672   4              SaveLedData0.Saveed=0;
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 12  

 673   4              UpdateLcdPowerDisplay(SaveLedData0.SelectedLedChanel,tpv,1);
 674   4              WriteDriverAddressValue(0x13+SaveLedData0.SelectedLedChanel,tpv);
 675   4            }
 676   3            else 
 677   3            { 
 678   4              SelectChDelayCounter=0;
 679   4              tpv=SaveLedData0.SelectedLedChanel;
 680   4              UpdateLCDLEDSelected(tpv,0);
 681   4              if (tpv<(SaveLedData0.LedALLChanels)) tpv++; else tpv=1;
 682   4              SaveLedData0.SelectedLedChanel=tpv;
 683   4              UpdateLCDLEDSelected(tpv,1);
 684   4              MovetoOtherLedch=1;
 685   4            }
 686   3          }
 687   2          else 
 688   2          {
 689   3            if (LCD_DISPiD==2)
 690   3            {
 691   4              if (SaveLedData0.LedALLChanels<4) SaveLedData0.LedALLChanels++; 
 692   4              DispSettingNumber(LCD_DISPiD,SaveLedData0.LedALLChanels);
 693   4              SaveLedData0.SelectedLedChanel=1;
 694   4            }
 695   3            else if (LCD_DISPiD==3)
 696   3            {
 697   4              tpv=SaveLedData0.MotorStepPluses;
 698   4              if (tpv<(255-ABEncoderAAC)) tpv+=ABEncoderAAC; else tpv=255;
 699   4              SaveLedData0.MotorStepPluses=tpv;
 700   4              ABEncoderACCCounter=0;
 701   4              if (ABEncoderAAC<10) ABEncoderAAC++;
 702   4              DispSettingNumber(LCD_DISPiD,tpv);
 703   4              WriteDriverAddressValue(0X1d,tpv);
 704   4            }
 705   3            
 706   3            else if (LCD_DISPiD>3 && LCD_DISPiD<=7)
 707   3            {
 708   4              tpv=SaveLedData0.LEDMotorLocation[LCD_DISPiD-3];
 709   4              if (tpv<254) tpv+=1; else tpv=255;
 710   4              //if (tpv<(255-ABEncoderAAC)) tpv+=ABEncoderAAC; else tpv=255;
 711   4              //ABEncoderACCCounter=0;
 712   4              //if (ABEncoderAAC<10) ABEncoderAAC++;
 713   4              SaveLedData0.LEDMotorLocation[LCD_DISPiD-3]=tpv;
 714   4              DispSettingNumber(LCD_DISPiD,tpv);
 715   4              WriteDriverAddressValue(0X16+LCD_DISPiD-1,tpv);
 716   4              WriteDriverAddressValue2(0X11,LCD_DISPiD-3,1); //选择LED，点亮LED
 717   4            }
 718   3            else if (LCD_DISPiD==8)
 719   3            {
 720   4              SaveLedData0.DriverFanOnOff=1;
 721   4              DispSettingNumber(2,1);
 722   4              WriteDriverAddressValue(0X1e,1);
 723   4            }
 724   3            
 725   3             else if (LCD_DISPiD==9)
 726   3            {
 727   4              SaveLedData0.PurpleLamp=1;
 728   4              DispSettingNumber(3,1);
 729   4              WriteDriverAddressValue(0X20,1);
 730   4            }
 731   3            
 732   3          }
 733   2      
 734   2        }
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 13  

 735   1        
 736   1        else if (ABEncoderDir==0xff)
 737   1        {
 738   2          ABEncoderDir=0;
 739   2          if (LCD_DISPiD==1)
 740   2          {
 741   3            
 742   3            if (SaveLedData0.LedOnOff==1)
 743   3            {
 744   4              tpv=SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel];
 745   4              if (tpv>ABEncoderAAC) tpv-=ABEncoderAAC; else tpv=1;
 746   4              ABEncoderACCCounter=0;
 747   4              if (ABEncoderAAC<10) ABEncoderAAC++;
 748   4              SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel]=tpv;
 749   4              SaveLedData0.Saveed=0;
 750   4              UpdateLcdPowerDisplay(SaveLedData0.SelectedLedChanel,tpv,1);
 751   4              WriteDriverAddressValue(0x13+SaveLedData0.SelectedLedChanel,tpv);
 752   4            }
 753   3            else 
 754   3            {
 755   4              SelectChDelayCounter=0;
 756   4              tpv=SaveLedData0.SelectedLedChanel;
 757   4              UpdateLCDLEDSelected(tpv,0);
 758   4              if (tpv>1) tpv--; else tpv=SaveLedData0.LedALLChanels;
 759   4              SaveLedData0.SelectedLedChanel=tpv;
 760   4              UpdateLCDLEDSelected(tpv,1);
 761   4              MovetoOtherLedch=1;
 762   4            }
 763   3          }
 764   2          else 
 765   2          {
 766   3            if (LCD_DISPiD==2)
 767   3            {
 768   4              if (SaveLedData0.LedALLChanels>1) SaveLedData0.LedALLChanels--; 
 769   4              DispSettingNumber(LCD_DISPiD,SaveLedData0.LedALLChanels);
 770   4            }
 771   3            else if (LCD_DISPiD==3)
 772   3            {
 773   4              tpv=SaveLedData0.MotorStepPluses;
 774   4          
 775   4              if (tpv>(ABEncoderAAC+1)) tpv-=ABEncoderAAC; else tpv=1;
 776   4              SaveLedData0.MotorStepPluses=tpv;
 777   4              ABEncoderACCCounter=0;
 778   4              if (ABEncoderAAC<10) ABEncoderAAC++;
 779   4              DispSettingNumber(LCD_DISPiD,tpv);
 780   4              WriteDriverAddressValue(0X1d,tpv);  //设置LED 每步脉冲
 781   4            }
 782   3            else if (LCD_DISPiD>3 && LCD_DISPiD<=7)
 783   3            {
 784   4              tpv=SaveLedData0.LEDMotorLocation[LCD_DISPiD-3];
 785   4              if (tpv>0) tpv-=1; else tpv=0;
 786   4            //  if (tpv>ABEncoderAAC) tpv-=ABEncoderAAC; else tpv=0;
 787   4            //  ABEncoderACCCounter=0;
 788   4            //  if (ABEncoderAAC<10) ABEncoderAAC++;
 789   4              SaveLedData0.LEDMotorLocation[LCD_DISPiD-3]=tpv;
 790   4              DispSettingNumber(LCD_DISPiD,tpv);
 791   4              WriteDriverAddressValue(0X16+LCD_DISPiD-1,tpv);//发送led 位置信息
 792   4              WriteDriverAddressValue2(0X11,LCD_DISPiD-3,1);//发送选择的led 和 开灯
 793   4          
 794   4            }
 795   3            else if (LCD_DISPiD==8)
 796   3            {
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 14  

 797   4              SaveLedData0.DriverFanOnOff=0;
 798   4              DispSettingNumber(2,0);
 799   4              WriteDriverAddressValue(0X1e,0);
 800   4            }
 801   3            
 802   3              else if (LCD_DISPiD==9)
 803   3            {
 804   4              SaveLedData0.PurpleLamp=0;
 805   4              DispSettingNumber(3,0);
 806   4              WriteDriverAddressValue(0X20,0);
 807   4            }
 808   3            
 809   3          }
 810   2        }
 811   1      
 812   1        if (P32==0)//编码器按键
 813   1          {
 814   2          delay_ms(5);
 815   2          if (P32==0)
 816   2          {
 817   3          /*
 818   3            for (tpv=0;tpv<100;tpv++)
 819   3              {
 820   3              delay_ms(30);
 821   3              if (P32==1) break;
 822   3              }
 823   3            if(P32==0)
 824   3              {
 825   3              DisplaySetting();
 826   3              Beep();  //进入设置界面
 827   3              }
 828   3            else*/
 829   3              {
 830   4              Beep();
 831   4              if (LCD_DISPiD==1)// && GetDriverBoardReturn==1)
 832   4                {
 833   5                if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
 834   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 835   5                }
 836   4              else if (LCD_DISPiD>=2)
 837   4                {
 838   5                LCD_DISPiD++; 
 839   5                if (LCD_DISPiD==3) 
 840   5                  {
 841   6                  DispSettingRectangle();
 842   6                  WriteDriverAddressValue(0X1d,SaveLedData0.MotorStepPluses);  //设置LED 每步脉冲
 843   6                  }
 844   5                else if (LCD_DISPiD<=7) 
 845   5                  {
 846   6                  DispSettingRectangle();
 847   6                  WriteDriverAddressValue2(0X11,LCD_DISPiD-3,1);// update led selection and on off
 848   6                  }
 849   5                else if (LCD_DISPiD==8) //driver fan onoff
 850   5                  {
 851   6                    DisplaySetting1();              
 852   6                  }
 853   5                  else if(LCD_DISPiD==9)
 854   5                  {
 855   6                    DisplaySetting2();
 856   6                  }
 857   5                else 
 858   5                  {
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 15  

 859   6                  LCD_DISPiD=1;
 860   6                  LCD_DrawWorkScreen();
 861   6                  NeedSaveData=1;  //需要保存
 862   6                  WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 863   6                  }
 864   5                
 865   5                }
 866   4              }
 867   3      
 868   3            while (P32==0) 
 869   3              {
 870   4              WDTRST;
 871   4              while (P32==0)  delay_ms(5);
 872   4              }
 873   3          }
 874   2        }
 875   1      
 876   1      
 877   1      /*
 878   1        
 879   1        if (ABEncoderDir==1)
 880   1        {
 881   1          ABEncoderDir=2;
 882   1          
 883   1        }
 884   1        else if (ABEncoderDir==0xff)
 885   1        {
 886   1          ABEncoderDir=2;
 887   1          
 888   1        }
 889   1         */
 890   1      
 891   1      //   ABEncoderStep=;
 892   1         if ((P3&0X88)==0x88) ABEncoderDir=0;
 893   1      
 894   1      
 895   1        
 896   1      
 897   1        if (P26==0)
 898   1        {
 899   2          delay_ms(5);
 900   2          if (P26==0)
 901   2          {
 902   3            Beep();
 903   3              if (LCD_DISPiD==1)
 904   3               {
 905   4                if (SaveLedData0.SelectedLedChanel==1)
 906   4                {
 907   5                  if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
 908   5                  WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 909   5                }
 910   4                else
 911   4                {
 912   5                  UpdateSelcetedLed(1);
 913   5                  UpdateSelectedLedOnOff(1); 
 914   5                  WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 915   5                }
 916   4               }
 917   3            
 918   3              while (P26==0) 
 919   3              {
 920   4              WDTRST;
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 16  

 921   4              while (P26==0)  
 922   4                {
 923   5                
 924   5                if (P01==0)
 925   5                  {
 926   6                  for (tpv=0;tpv<100;tpv++)
 927   6                  {
 928   7                    delay_ms(30);
 929   7                    if (P26!=0 || P01!=0) break;
 930   7                    }
 931   6                    if (P26==0 && P01==0)
 932   6                      {
 933   7                      DisplaySetting();
 934   7                      Beep();  //进入设置界面
 935   7                      }
 936   6                    while (P26==0 || P01==0) 
 937   6                    {
 938   7                    WDTRST;
 939   7                    while (P26==0 || P01==0)  delay_ms(5);
 940   7                  }
 941   6                  }
 942   5                else 
 943   5                  delay_ms(5);
 944   5                }
 945   4              }
 946   3            }
 947   2        }
 948   1        
 949   1        if (P27==0)
 950   1        {
 951   2          delay_ms(5);
 952   2          if (P27==0)
 953   2          {
 954   3            Beep();
 955   3            if (LCD_DISPiD==1)
 956   3             {
 957   4              if (SaveLedData0.SelectedLedChanel==2)
 958   4              {
 959   5                if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
 960   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 961   5              }
 962   4              else  if (SaveLedData0.LedALLChanels>1)
 963   4              {
 964   5                UpdateSelcetedLed(2);
 965   5                UpdateSelectedLedOnOff(1); 
 966   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 967   5              }
 968   4            }
 969   3             else
 970   3             {
 971   4             if (LCD_DISPiD==2)
 972   4               {
 973   5              if (SaveLedData0.LedALLChanels<4) SaveLedData0.LedALLChanels++; 
 974   5              DispSettingNumber(LCD_DISPiD,SaveLedData0.LedALLChanels);
 975   5              SaveLedData0.SelectedLedChanel=1;
 976   5               }
 977   4               else if (LCD_DISPiD==3)
 978   4            {
 979   5              tpv=SaveLedData0.MotorStepPluses;
 980   5              if (tpv<(255-ABEncoderAAC)) tpv+=ABEncoderAAC; else tpv=255;
 981   5              SaveLedData0.MotorStepPluses=tpv;
 982   5              ABEncoderACCCounter=0;
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 17  

 983   5              if (ABEncoderAAC<10) ABEncoderAAC++;
 984   5              DispSettingNumber(LCD_DISPiD,tpv);
 985   5              WriteDriverAddressValue(0X1d,tpv);
 986   5            }
 987   4            
 988   4            else if (LCD_DISPiD>3 && LCD_DISPiD<=7)
 989   4            {
 990   5              tpv=SaveLedData0.LEDMotorLocation[LCD_DISPiD-3];
 991   5              if (tpv<254) tpv+=1; else tpv=255;
 992   5              //if (tpv<(255-ABEncoderAAC)) tpv+=ABEncoderAAC; else tpv=255;
 993   5              //ABEncoderACCCounter=0;
 994   5              //if (ABEncoderAAC<10) ABEncoderAAC++;
 995   5              SaveLedData0.LEDMotorLocation[LCD_DISPiD-3]=tpv;
 996   5              DispSettingNumber(LCD_DISPiD,tpv);
 997   5              WriteDriverAddressValue(0X16+LCD_DISPiD-1,tpv);
 998   5              WriteDriverAddressValue2(0X11,LCD_DISPiD-3,1); //选择LED，点亮LED
 999   5            }
1000   4            else if (LCD_DISPiD==8)
1001   4            {
1002   5              SaveLedData0.DriverFanOnOff=1;
1003   5              DispSettingNumber(2,1);
1004   5              WriteDriverAddressValue(0X1e,1);
1005   5            }
1006   4            
1007   4             else if (LCD_DISPiD==9)
1008   4            {
1009   5              SaveLedData0.PurpleLamp=1;
1010   5              DispSettingNumber(3,1);
1011   5              WriteDriverAddressValue(0X20,1);
1012   5            }
1013   4             }
1014   3            while (P27==0) 
1015   3              {
1016   4              WDTRST;
1017   4              while (P27==0)  delay_ms(5);
1018   4              }
1019   3          }
1020   2        }
1021   1      
1022   1        if (P00==0)
1023   1        {
1024   2          delay_ms(5);
1025   2          if (P00==0)
1026   2          {
1027   3            Beep();
1028   3            if (LCD_DISPiD==1)
1029   3            {
1030   4              if (SaveLedData0.SelectedLedChanel==3)
1031   4              {
1032   5                if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
1033   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
1034   5              }
1035   4              else if (SaveLedData0.LedALLChanels>2)
1036   4              {
1037   5                UpdateSelcetedLed(3);
1038   5                UpdateSelectedLedOnOff(1); 
1039   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
1040   5              }
1041   4            }
1042   3            else 
1043   3          {
1044   4            if (LCD_DISPiD==2)
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 18  

1045   4            {
1046   5              if (SaveLedData0.LedALLChanels>1) SaveLedData0.LedALLChanels--; 
1047   5              DispSettingNumber(LCD_DISPiD,SaveLedData0.LedALLChanels);
1048   5            }
1049   4            else if (LCD_DISPiD==3)
1050   4            {
1051   5              tpv=SaveLedData0.MotorStepPluses;
1052   5          
1053   5              if (tpv>(ABEncoderAAC+1)) tpv-=ABEncoderAAC; else tpv=1;
1054   5              SaveLedData0.MotorStepPluses=tpv;
1055   5              ABEncoderACCCounter=0;
1056   5              if (ABEncoderAAC<10) ABEncoderAAC++;
1057   5              DispSettingNumber(LCD_DISPiD,tpv);
1058   5              WriteDriverAddressValue(0X1d,tpv);  //设置LED 每步脉冲
1059   5            }
1060   4            else if (LCD_DISPiD>3 && LCD_DISPiD<=7)
1061   4            {
1062   5              tpv=SaveLedData0.LEDMotorLocation[LCD_DISPiD-3];
1063   5              if (tpv>0) tpv-=1; else tpv=0;
1064   5            //  if (tpv>ABEncoderAAC) tpv-=ABEncoderAAC; else tpv=0;
1065   5            //  ABEncoderACCCounter=0;
1066   5            //  if (ABEncoderAAC<10) ABEncoderAAC++;
1067   5              SaveLedData0.LEDMotorLocation[LCD_DISPiD-3]=tpv;
1068   5              DispSettingNumber(LCD_DISPiD,tpv);
1069   5              WriteDriverAddressValue(0X16+LCD_DISPiD-1,tpv);//发送led 位置信息
1070   5              WriteDriverAddressValue2(0X11,LCD_DISPiD-3,1);//发送选择的led 和 开灯   
1071   5            }
1072   4            else if (LCD_DISPiD==8)
1073   4            {
1074   5              SaveLedData0.DriverFanOnOff=0;
1075   5              DispSettingNumber(2,0);
1076   5              WriteDriverAddressValue(0X1e,0);
1077   5            }
1078   4            
1079   4              else if (LCD_DISPiD==9)
1080   4            {
1081   5              SaveLedData0.PurpleLamp=0;
1082   5              DispSettingNumber(3,0);
1083   5              WriteDriverAddressValue(0X20,0);
1084   5            }
1085   4          }
1086   3            while (P00==0) 
1087   3              {
1088   4              WDTRST;
1089   4              while (P00==0)  delay_ms(5);
1090   4              }
1091   3          }
1092   2        }
1093   1      
1094   1        if (P01==0)
1095   1        {
1096   2          delay_ms(5);
1097   2          if (P01==0)
1098   2          {
1099   3            Beep();
1100   3            
1101   3            if (LCD_DISPiD==1)
1102   3            {
1103   4              if (SaveLedData0.SelectedLedChanel==4)
1104   4              {
1105   5                if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
1106   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 19  

1107   5              }
1108   4              else if (SaveLedData0.LedALLChanels>3)
1109   4              {
1110   5                UpdateSelcetedLed(4);
1111   5                UpdateSelectedLedOnOff(1); 
1112   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
1113   5              }
1114   4            }
1115   3                  else if (LCD_DISPiD>=2)
1116   3                {
1117   4                LCD_DISPiD++; 
1118   4                if (LCD_DISPiD==3) 
1119   4                  {
1120   5                  DispSettingRectangle();
1121   5                  WriteDriverAddressValue(0X1d,SaveLedData0.MotorStepPluses);  //设置LED 每步脉冲
1122   5                  }
1123   4                else if (LCD_DISPiD<=7) 
1124   4                  {
1125   5                  DispSettingRectangle();
1126   5                  WriteDriverAddressValue2(0X11,LCD_DISPiD-3,1);// update led selection and on off
1127   5                  }
1128   4                else if (LCD_DISPiD==8) //driver fan onoff
1129   4                  {
1130   5                    DisplaySetting1();              
1131   5                  }
1132   4                  else if(LCD_DISPiD==9)
1133   4                  {
1134   5                    DisplaySetting2();
1135   5                  }
1136   4                  else 
1137   4                  {
1138   5                  LCD_DISPiD=1;
1139   5                  LCD_DrawWorkScreen();
1140   5                  NeedSaveData=1;  //需要保存
1141   5                  WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
1142   5                  }
1143   4                }
1144   3            while (P01==0) 
1145   3              {
1146   4              WDTRST;
1147   4              while (P01==0) 
1148   4                {
1149   5                if (P26==0)
1150   5                  {
1151   6                  for (tpv=0;tpv<100;tpv++)
1152   6                  {
1153   7                  delay_ms(30);
1154   7                  if (P26!=0 || P01!=0) break;
1155   7                  }
1156   6                  if (P26==0 && P01==0)
1157   6                    {
1158   7                    DisplaySetting();
1159   7                    Beep();  //进入设置界面
1160   7                    }
1161   6                  while (P26==0 || P01==0) 
1162   6                    {
1163   7                    WDTRST;
1164   7                    while (P26==0 || P01==0)  delay_ms(5);
1165   7                    }
1166   6                  }
1167   5                else 
1168   5                  delay_ms(5);
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 20  

1169   5                }
1170   4              }
1171   3          }
1172   2        }
1173   1      
1174   1      
1175   1        if (UsbCmdUpdate!=0)
1176   1        {
1177   2          UsbCmdUpdate=0;
1178   2          DoUart4CmdPro();
1179   2        }
1180   1      }
1181          
1182          void ExClockConfig(void)
1183          {
1184   1      // u32 timeoutcounter=0;
1185   1        P_SW2 = 0x80;
1186   1        XOSCCR = 0xc0;                //???ˉía2??§??
1187   1        while (!(XOSCCR & 1) ) 
1188   1          {
1189   2          WDTRST;        //μè′yê±?ó?è?¨
1190   2          }
1191   1        CLKDIV = 0x00;                 //ê±?ó2?・??μ
1192   1        CKSEL = 0x01;               //????ía2??§??
1193   1        P_SW2 = 0x00;
1194   1      }
1195          
1196          
1197          void main()
1198          {
1199   1        
1200   1        ExClockConfig();
1201   1        if(CmpDataFlashUuid()==0) while (1);
1202   1        Gpio_Init();
1203   1        Uart2Init();   //DRIVER BOARD
1204   1        Uart4Init();  //USB
1205   1        lcd_initial();
1206   1        Timer0Init();
1207   1        SPI_FLASH_Init();
1208   1        delay_ms(100);
1209   1        Gui_DrawFlashbmp16(0,0,0);
1210   1      //  
1211   1      //  Display_ASCII8X16(50,16,"EasyLWL",7,BLUE);
1212   1        CtrlLcdBL(1);
1213   1        EA=1;
1214   1        ReadDriverAddressValue(0x10,1);
1215   1        Beep();
1216   1        ReadEEpromSaveData();
1217   1        ReadDriverAddressValue(0x10,1);
1218   1      
1219   1        //开机加载画
1220   1        while (StartDelayCounter<MAXSTARTDELAYTIME)  //等待开机停留时间, lcd 应答
1221   1          {
1222   2          WDTRST;  
1223   2          if ((StartDelayCounter>=MINSTARTDELAYTIME) &&(GetDriverBoardReturn!=0)) break;
1224   2          if (NeedUpdateLEDValue)
1225   2          {
1226   3          NeedUpdateLEDValue=0;
1227   3          GetDriverBoardReturn=0;
1228   3          ReadDriverAddressValue(0x10,1); //心跳包
1229   3          }
1230   2          DoUart2Pkg();  //driver board
C51 COMPILER V9.59.0.0   MAIN                                                              04/01/2024 20:57:26 PAGE 21  

1231   2          }
1232   1        
1233   1        NeedUpdateConnect=0;
1234   1        InitLcd();
1235   1        WriteDriverSqAddressValue(0X10,&(SaveLedData0.DriverType),sizeof(Run_PARAMS));
1236   1        /* Infinite loop */
1237   1        while (1)
1238   1        {
1239   2          WDTRST;                      //清看门狗,否则系统复位
1240   2          DoUart2Pkg();  //driver board
1241   2          //DoUart4Pkg();   //usb uart4 interrupt sub run 
1242   2        CheckButton();
1243   2        HandleLCD();
1244   2        }
1245   1      }
1246          
1247          
1248          
1249          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7009    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    348    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
