C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OMF2 OPTIMIZE(0,SIZE) BROWSE ORDER INCDIR(..\Src;.\LCD) DEB
                    -UG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file    Project/main.c 
   4            * @author  MCD Application Team
   5            * @version V2.2.0
   6            * @date    30-September-2014
   7            * @brief   Main program body
   8           */
   9          /* Includes ------------------------------------------------------------------*/
  10          #include "main.h"
  11          #include "lcd.h"
  12          #include "ABencoder.h"
  13          #include "uarttask.h"
  14          #include "spi_flash.h"
  15          #include "eeprom.h"
  16          #include "SaveConfigfile.h"
  17          #include "uuid.h"
  18          /* Private defines -----------------------------------------------------------*/
  19          
  20          #define NOREPLSYTIMES 5
  21          #define MAXSTARTDELAYTIME 10
  22          #define MINSTARTDELAYTIME 3
  23          
  24          
  25          #define EX2             0x10
  26          #define EX3             0x20
  27          #define EX4             0x40
  28          
  29          
  30          sbit LED = P2^1;
  31          
  32          /* Private function prototypes -----------------------------------------------*/
  33          /* Private functions ---------------------------------------------------------*/
  34          void InitLcd(void);
  35          
  36           
  37           
  38          u8 UsbCmdUpdate=0;
  39          u8 usbCmdCode=0;
  40          u8 usbWRAddr,usbWRData;
  41          //UARTST_PKG  uart1rcpkg;
  42          UARTST_PKG uart2rcpkg;
  43          //UARTST_PKG uart3rcpkg;
  44          UARTST4_PKG uart4rcpkg;
  45          
  46          uint8_t LCD_DISPiD=0;
  47          uint8_t NeedUpdateLEDValue=0,NeedUpdateConnect=0,NeedSaveData=0;
  48          
  49          u8 DriverBoardConnetStatus=0;
  50          u8 DriverBoardNoReplyCounter=0;
  51          u8 LedShareCounter=0;
  52          u8 SelectData=0;
  53          u8 UpdateTHCounter=0;
  54          u8 RunModel=0;
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 2   

  55          u8 StartDelayCounter=0;
  56          u8 SaveEEpromDelaycounter=0;
  57          u8 Temperature=0,Humidity=0;
  58          u8 GetDriverBoardReturn=0;
  59          
  60          u8 ABEncoderACCCounter=0;
  61          u8 ABEncoderAAC=1;
  62          
  63          
  64          u8 SelectChDelayCounter=0;
  65          u8 AutoOnLedCh=0;
  66          u8 MovetoOtherLedch=0;
  67          
  68          void delay_us(uint16_t dt)
  69          {
  70   1        dt = dt<<1;
  71   1        while (--dt) WDTRST;
  72   1      }
  73            
  74          
  75          
  76          void delay_ms(uint16_t dt)
  77          {
  78   1       while (dt>0)
  79   1        {
  80   2        delay_us(400);
  81   2        dt--;
  82   2        }
  83   1      }
  84          
  85          void ClearMemory(uint8_t * ptr,uint8_t len)
  86          {
  87   1        uint8_t i;
  88   1         for (i=0;i<len;i++)  
  89   1          {
  90   2          *ptr=0;
  91   2          ptr++;
  92   2          }
  93   1      }
  94          
  95          void SetMemory(uint8_t * ptr,uint8_t len)
  96          {
  97   1        uint8_t i;
  98   1         for (i=0;i<len;i++)  
  99   1          {
 100   2          *ptr=0xff;
 101   2          ptr++;
 102   2          }
 103   1      }
 104          
 105          void Memcpy2(u8* src, u8* dec,u8 len)
 106          {
 107   1        uint8_t i;
 108   1         for (i=0;i<len;i++)  
 109   1          {
 110   2          *dec=*src;
 111   2          src++;
 112   2          dec++;
 113   2          }
 114   1      }
 115          
 116          u8 cmpMemory(u8* ptr, u8* dec ,u8 len)
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 3   

 117          {
 118   1        uint8_t i;
 119   1         for (i=0;i<len;i++)  
 120   1          {
 121   2          if ((*dec)!=(*ptr)) return 0;
 122   2          ptr++;
 123   2          dec++;
 124   2          }
 125   1         return 1;
 126   1      }
 127          
 128          
 129          
 130          
 131          
 132          void Gpio_Init(void)
 133          {
 134   1        
 135   1        P26=1; P27=1;P00=1;P01=1; // 按键1-4
 136   1      
 137   1        
 138   1        P32=1;P33=1;P36=0;P37=1;//编码器输入
 139   1        P20=1; //speaker
 140   1        LED=0; //LED
 141   1        
 142   1        P0M0=0;
 143   1        P0M1=0;
 144   1        
 145   1        P1M0=0;
 146   1        P1M1=0;+
 147   1        
 148   1        P2M0=0x2E;
 149   1        P2M1=0;
 150   1      
 151   1        P3M0=0X40;
 152   1        P3M1=0;
 153   1      
 154   1        P5M0=0X10;
 155   1        P5M1=0;
 156   1      
 157   1        IT1 = 1;                                    //使能INT1 下降沿中断
 158   1          EX1 = 1;                                    //使能INT1中断
 159   1        INTCLKO = EX3;                              //使能INT3中断
 160   1      
 161   1      }
 162          
 163          void Beep(void)
 164          {
 165   1        P20=0;  //SPK
 166   1        delay_ms(100);
 167   1        P20=1;
 168   1      }
 169          
 170          void Timer0Init(void)   //20毫秒@33.1776MHz
 171          {
 172   1        AUXR &= 0x7F;   //定时器时钟12T模式
 173   1        TMOD &= 0xF0;   //设置定时器模式
 174   1        TL0 = 0x00;   //设置定时初值
 175   1        TH0 = 0x28;   //设置定时初值
 176   1        ET0 = 1;                                   
 177   1        TF0 = 0;    //清除TF0标志
 178   1        TR0 = 1;    //定时器0开始计时
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 4   

 179   1      }
 180          
 181          void UpdateSelectedLedOnOff(u8 nonoff)
 182          {
 183   1        if (nonoff==0) MovetoOtherLedch=0;
 184   1        SaveLedData0.LedOnOff=nonoff;
 185   1        UpdateLCDLEDCloum(SaveLedData0.SelectedLedChanel,SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel],Sa
             -veLedData0.LedOnOff);
 186   1      }
 187          
 188          
 189          void UpdateSelcetedLed(u8 newSelCh)
 190          {
 191   1      
 192   1        if (SaveLedData0.SelectedLedChanel!=newSelCh)
 193   1        {
 194   2          UpdateLCDLEDCloum(SaveLedData0.SelectedLedChanel,SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel],0
             -);
 195   2          UpdateLCDLEDSelected(SaveLedData0.SelectedLedChanel,0); 
 196   2          SaveLedData0.SelectedLedChanel=newSelCh;
 197   2          UpdateLCDLEDSelected(SaveLedData0.SelectedLedChanel,1); 
 198   2          UpdateSelectedLedOnOff(SaveLedData0.LedOnOff);
 199   2        }
 200   1      }
 201          
 202          
 203          
 204          //time0 定时超时判断
 205          void Time0OutDelaySub(void)
 206          {
 207   1      
 208   1        if (uart2rcpkg.RecStatus!=REC_HEAD1)
 209   1          {
 210   2          uart2Memory.UartPkgTimeoutCounter++;
 211   2          if (uart2Memory.UartPkgTimeoutCounter>50)
 212   2            {
 213   3            uart2Memory.UartPkgTimeoutCounter=0;
 214   3            uart2rcpkg.RecStatus=REC_HEAD1;
 215   3            }
 216   2          }
 217   1          
 218   1        if (uart4rcpkg.RecStatus!=REC2_HEAD1)
 219   1          {
 220   2          uart4rcpkg.UartPkgTimeoutCounter++;
 221   2          if (uart4rcpkg.UartPkgTimeoutCounter>50)
 222   2            {
 223   3            uart4rcpkg.UartPkgTimeoutCounter=0;
 224   3            uart4rcpkg.RecStatus=REC2_HEAD1;
 225   3            }
 226   2          }
 227   1      
 228   1        if (uart4rcpkg.UsbCmdStatus!=REC4_HEAD1)
 229   1          {
 230   2          uart4rcpkg.UartPkgTimeoutCounter++;
 231   2          if (uart4rcpkg.UartPkgTimeoutCounter>50)
 232   2            {
 233   3            uart4rcpkg.UartPkgTimeoutCounter=0;
 234   3            uart4rcpkg.UsbCmdStatus=REC4_HEAD1;
 235   3            }
 236   2          }
 237   1      
 238   1        if (SaveLedData0.Saveed==0 &&  ABEncoderDir==0) 
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 5   

 239   1          {
 240   2          if (SaveEEpromDelaycounter>=150)   //3秒
 241   2            {
 242   3            NeedSaveData=1;
 243   3            }
 244   2          else
 245   2            {
 246   3            SaveEEpromDelaycounter++;
 247   3            }
 248   2          }
 249   1        else 
 250   1          {
 251   2          SaveEEpromDelaycounter=0;
 252   2          }
 253   1        
 254   1      
 255   1        if (ABEncoderAAC!=1) ABEncoderACCCounter++;
 256   1      
 257   1        if (ABEncoderACCCounter>=15)
 258   1          {
 259   2          ABEncoderACCCounter=0;
 260   2          ABEncoderAAC=1;
 261   2          }
 262   1        
 263   1      
 264   1        if ((LCD_DISPiD==1) && (SaveLedData0.LedOnOff==0) && (MovetoOtherLedch==1)) SelectChDelayCounter++;
 265   1        if (SelectChDelayCounter>75)  
 266   1        {
 267   2          SelectChDelayCounter=0;
 268   2          AutoOnLedCh=1;
 269   2          MovetoOtherLedch=0;
 270   2        }
 271   1        
 272   1      
 273   1        LedShareCounter++;
 274   1        if (LedShareCounter==25)   //0.5秒
 275   1          {
 276   2          LED=!LED;
 277   2          
 278   2          }
 279   1        else if (LedShareCounter>=50)  //1秒
 280   1          {
 281   2          LedShareCounter=0;
 282   2          NeedUpdateLEDValue=1;
 283   2          
 284   2          LED=!LED;
 285   2          if (StartDelayCounter<MAXSTARTDELAYTIME)  StartDelayCounter++;
 286   2          
 287   2        if (GetDriverBoardReturn==1) 
 288   2          {
 289   3            DriverBoardNoReplyCounter=0;
 290   3            if (DriverBoardConnetStatus==0) NeedUpdateConnect=1;
 291   3            DriverBoardConnetStatus=1;
 292   3            
 293   3          }
 294   2        else 
 295   2          {
 296   3            if (DriverBoardConnetStatus==1) DriverBoardNoReplyCounter++;
 297   3            if (DriverBoardNoReplyCounter>NOREPLSYTIMES)  
 298   3              {
 299   4              DriverBoardNoReplyCounter=0;
 300   4              DriverBoardConnetStatus=0;
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 6   

 301   4              NeedUpdateConnect=1;
 302   4              }
 303   3            //GetDriverBoardReturn=0;
 304   3          } 
 305   2          }
 306   1      }
 307          
 308          void InitLcd(void)
 309          {
 310   1        if (GetDriverBoardReturn==0)  //驱动板没有返回
 311   1          {
 312   2          DisplayDisconnect();
 313   2          }
 314   1        else 
 315   1          {
 316   2          LCD_DrawWorkScreen();
 317   2          }
 318   1      }
 319          
 320          
 321          
 322          
 323          
 324          void ReturnWrUart4CmdUsb(u8 Wraddr,u8 WrData)
 325          {
 326   1         u8 addrsum=0;
 327   1         
 328   1         while (uart4rcpkg.busy==1) WDTRST;    
 329   1         uart4rcpkg.busy=1;
 330   1         S4BUF=0x69;
 331   1         while (uart4rcpkg.busy==1) WDTRST;    
 332   1         uart4rcpkg.busy=1;
 333   1         S4BUF=0x96;
 334   1         while (uart4rcpkg.busy==1) WDTRST;    
 335   1         uart4rcpkg.busy=1;
 336   1         S4BUF=usbCmdCode;
 337   1         addrsum+=usbCmdCode;
 338   1          while (uart4rcpkg.busy==1) WDTRST;    
 339   1         uart4rcpkg.busy=1;
 340   1         S4BUF=Wraddr;
 341   1         addrsum+=Wraddr;
 342   1          while (uart4rcpkg.busy==1) WDTRST;    
 343   1         uart4rcpkg.busy=1;
 344   1         S4BUF=WrData;
 345   1         addrsum+=WrData;
 346   1         while (uart4rcpkg.busy==1) WDTRST;    
 347   1         uart4rcpkg.busy=1;
 348   1         S4BUF=addrsum;
 349   1         
 350   1      }
 351          
 352          
 353          void DoUart4CmdPro(void)
 354          {
 355   1      if (usbCmdCode==0x80)  //write
 356   1        {
 357   2          if (usbWRAddr==0x10)
 358   2          {
 359   3          if (usbWRData==0) usbWRData=1;
 360   3          else if (usbWRData>4) usbWRData=4;
 361   3          if (SaveLedData0.LedALLChanels!=usbWRData)
 362   3            {
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 7   

 363   4              SaveLedData0.LedALLChanels=usbWRData;
 364   4              NeedSaveData=1;  //需要保存
 365   4              SaveLedData0.SelectedLedChanel=1;
 366   4              WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 367   4              if (LCD_DISPiD==1)
 368   4              {
 369   5                LCD_DrawWorkScreen();
 370   5              } 
 371   4              else 
 372   4              {
 373   5                DispSettingNumber(2,SaveLedData0.LedALLChanels);
 374   5              }
 375   4              SaveLedData0.Saveed=0;
 376   4            }
 377   3          }
 378   2          else if (usbWRAddr==0x11)
 379   2          {
 380   3            if (usbWRData==0) usbWRData=1; 
 381   3            else if (usbWRData>4) usbWRData=4;
 382   3            if (SaveLedData0.SelectedLedChanel!=usbWRData)
 383   3              {
 384   4              if (LCD_DISPiD==1)
 385   4                {
 386   5                UpdateSelcetedLed(usbWRData);
 387   5                }
 388   4              else 
 389   4                {
 390   5                SaveLedData0.SelectedLedChanel=usbWRData;
 391   5                }
 392   4              WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 393   4              SaveLedData0.Saveed=0;
 394   4              }
 395   3          }
 396   2          else if (usbWRAddr==0x12)
 397   2          {
 398   3            if (usbWRData>1) usbWRData=1;
 399   3            
 400   3            if (SaveLedData0.LedOnOff!=usbWRData)
 401   3              {
 402   4              if (LCD_DISPiD==1)
 403   4                {
 404   5                UpdateSelectedLedOnOff(usbWRData);
 405   5                }
 406   4              else 
 407   4                {
 408   5                SaveLedData0.LedOnOff=usbWRData;
 409   5                }
 410   4              WriteDriverAddressValue(0X12,SaveLedData0.LedOnOff);
 411   4              SaveLedData0.Saveed=0;
 412   4              }
 413   3          }
 414   2          else if (usbWRAddr>=0x14 && usbWRAddr<=0x17)
 415   2          {
 416   3            if (usbWRData>100) usbWRData=100;
 417   3            if (SaveLedData0.LedPower[usbWRAddr-0x13]!=usbWRData)
 418   3              {
 419   4              SaveLedData0.LedPower[usbWRAddr-0x13]=usbWRData;
 420   4              if (LCD_DISPiD==1)
 421   4                {
 422   5                UpdateLcdPowerDisplay(usbWRAddr-0x13,usbWRData,SaveLedData0.LedOnOff);
 423   5                }
 424   4              WriteDriverAddressValue(usbWRAddr,usbWRData);
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 8   

 425   4              SaveLedData0.Saveed=0;
 426   4              }
 427   3          }
 428   2          else if (usbWRAddr>=0x19 && usbWRAddr<=0x1c)
 429   2          {
 430   3            if (SaveLedData0.LEDMotorLocation[usbWRAddr-0x18]!=usbWRData)
 431   3              {
 432   4              SaveLedData0.LEDMotorLocation[usbWRAddr-0x18]=usbWRData;
 433   4              if (LCD_DISPiD>1)
 434   4                {
 435   5                DispSettingNumber((usbWRAddr-0x19)+4,usbWRData);
 436   5                }
 437   4              WriteDriverAddressValue(usbWRAddr,usbWRData);
 438   4              SaveLedData0.Saveed=0;
 439   4              }
 440   3          }
 441   2          else if (usbWRAddr==0x1d)
 442   2          {
 443   3            if (SaveLedData0.MotorStepPluses!=usbWRData)
 444   3              {
 445   4              SaveLedData0.MotorStepPluses=usbWRData;
 446   4              if (LCD_DISPiD>1)
 447   4                {
 448   5                DispSettingNumber(3,SaveLedData0.MotorStepPluses);
 449   5                }
 450   4              WriteDriverAddressValue(0X1d,usbWRData);
 451   4              SaveLedData0.Saveed=0;
 452   4              }
 453   3          }
 454   2        }
 455   1      else  if (uart4rcpkg.pic_N==0x81)  //read
 456   1        {
 457   2        if (usbWRAddr==0x10)
 458   2          {
 459   3          usbWRData=SaveLedData0.LedALLChanels;
 460   3          }
 461   2          else if (usbWRAddr==0x11)
 462   2          {
 463   3          usbWRData=SaveLedData0.SelectedLedChanel;
 464   3          }
 465   2          else if (usbWRAddr==0x12)
 466   2          {
 467   3          usbWRData=SaveLedData0.LedOnOff;
 468   3          }
 469   2          else if (usbWRAddr>=0x14 && usbWRAddr<=0x17)
 470   2          {
 471   3          usbWRData=SaveLedData0.LedPower[usbWRAddr-0x13];
 472   3          }
 473   2          else if (usbWRAddr>=0x19 && usbWRAddr<=0x1c)
 474   2          {
 475   3          usbWRData=SaveLedData0.LEDMotorLocation[usbWRAddr-0x18];
 476   3          }
 477   2          else if (usbWRAddr==0x1d)
 478   2          {
 479   3          usbWRData=SaveLedData0.MotorStepPluses;
 480   3          }
 481   2        }
 482   1      
 483   1        ReturnWrUart4CmdUsb(usbWRAddr,usbWRData);
 484   1      }
 485          
 486          
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 9   

 487          void HandleLCD(void)
 488          {
 489   1      static u8 ReadBytest=0;
 490   1        if (NeedUpdateLEDValue)
 491   1          {
 492   2          NeedUpdateLEDValue=0;
 493   2          GetDriverBoardReturn=0;
 494   2          if (ReadBytest==0)
 495   2            {
 496   3            ReadDriverAddressValue(0x10,1); //心跳包
 497   3            ReadBytest=1;
 498   3            }
 499   2          else if (ReadBytest==1)
 500   2            {
 501   3            ReadDriverAddressValue(0x11,1); //心跳包
 502   3            ReadBytest=2;
 503   3            }
 504   2          else
 505   2            {
 506   3            ReadDriverAddressValue(0x12,1); //心跳包
 507   3            ReadBytest=0;
 508   3            }
 509   2          }
 510   1        
 511   1        if (NeedUpdateConnect)
 512   1          {
 513   2          NeedUpdateConnect=0;
 514   2          WriteDriverSqAddressValue(0X10,&(SaveLedData0.DriverType),sizeof(Run_PARAMS));
 515   2          InitLcd();
 516   2          Beep();
 517   2          }
 518   1      
 519   1        if (NeedSaveData)
 520   1          {
 521   2          NeedSaveData=0;
 522   2          SaveLedData0.Saveed=1;
 523   2          WriteEEpromSaveData();
 524   2          }
 525   1      
 526   1        if (AutoOnLedCh )
 527   1        {
 528   2          AutoOnLedCh=0;
 529   2          if (LCD_DISPiD==1 && SaveLedData0.LedOnOff==0)
 530   2            {
 531   3            UpdateSelectedLedOnOff(1); 
 532   3            WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 533   3            }
 534   2        }
 535   1      }
 536          
 537          
 538          void DoRsUart2Cmd(void)
 539          {
 540   1        u8 i=0;
 541   1        u8 addrecode=uart2rcpkg.UartRunBuf[0];
 542   1        u8 datalen=uart2rcpkg.pklen-1;
 543   1        DriverBoardNoReplyCounter=0;
 544   1        GetDriverBoardReturn=1;
 545   1        if (DriverBoardConnetStatus==0)
 546   1          {
 547   2          DriverBoardConnetStatus=1;
 548   2          NeedUpdateConnect=1;
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 10  

 549   2          }
 550   1      
 551   1        if (addrecode==0x10)  
 552   1          {
 553   2            if (SaveLedData0.DriverType!=uart2rcpkg.UartRunBuf[1])
 554   2              {
 555   3              WriteDriverAddressValue(0X10,SaveLedData0.DriverType);
 556   3              }
 557   2          }
 558   1        else if (addrecode==0x11) 
 559   1          {
 560   2          if (SaveLedData0.SelectedLedChanel!=uart2rcpkg.UartRunBuf[1])
 561   2            {
 562   3            if (LCD_DISPiD==1)
 563   3              {
 564   4              /*
 565   4              if (SaveLedData0.DriverType==0)
 566   4                {
 567   4                UpdateSelcetedLed(uart2rcpkg.UartRunBuf[1]);
 568   4                }
 569   4              else*/
 570   4                {
 571   5                WriteDriverAddressValue(0X11,SaveLedData0.SelectedLedChanel);
 572   5                }
 573   4              }
 574   3            }
 575   2          }
 576   1        else if (addrecode==0x12)
 577   1      
 578   1          {
 579   2          if (SaveLedData0.LedOnOff!=uart2rcpkg.UartRunBuf[1])
 580   2            {
 581   3            WriteDriverAddressValue(0X12,SaveLedData0.LedOnOff);
 582   3            }
 583   2          }
 584   1      }
 585          
 586          
 587          u8 DoUart2Pkg(void)
 588          {
 589   1        u8 temp;
 590   1        
 591   1        if (uart2Memory.RxByteSize==0) return 0;
 592   1      
 593   1        temp=uart2Memory.RxBuffer[uart2Memory.ReadCounter];
 594   1        if (uart2Memory.ReadCounter<(RxBufferSize-1)) uart2Memory.ReadCounter++; else uart2Memory.ReadCounter=0;
 595   1        if(uart2Memory.RxByteSize>0)   uart2Memory.RxByteSize--;
 596   1        switch (uart2rcpkg.RecStatus)
 597   1        {
 598   2          case REC_HEAD1:
 599   2            if (temp==0X5A) uart2rcpkg.RecStatus=REC_HEAD2;
 600   2          break;
 601   2          case REC_HEAD2:
 602   2            if (temp==0XA5) uart2rcpkg.RecStatus=REC_RKLEN;
 603   2            else uart2rcpkg.RecStatus=REC_HEAD1;
 604   2          break;
 605   2          case REC_RKLEN:
 606   2          if (temp>24|| temp<1) 
 607   2              uart2rcpkg.RecStatus=REC_HEAD1;
 608   2            else 
 609   2              {
 610   3              uart2rcpkg.pklen=(uint8_t)(temp-1);
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 11  

 611   3              uart2rcpkg.RecStatus=REC_CMD;
 612   3              }
 613   2          break;
 614   2          case REC_CMD:
 615   2            if (temp!=0x82)
 616   2              uart2rcpkg.RecStatus=REC_HEAD1;
 617   2            else 
 618   2              {
 619   3              uart2rcpkg.cmd=temp;
 620   3              uart2rcpkg.bufwpoint=0;
 621   3              uart2rcpkg.RecStatus=REC_DATA;
 622   3              }
 623   2            
 624   2          break;
 625   2          case REC_DATA:
 626   2            uart2rcpkg.UartRunBuf[uart2rcpkg.bufwpoint]=temp;
 627   2            uart2rcpkg.bufwpoint++;
 628   2            if (uart2rcpkg.bufwpoint>=uart2rcpkg.pklen)
 629   2              {
 630   3                DoRsUart2Cmd();
 631   3                uart2rcpkg.RecStatus=REC_HEAD1;
 632   3                return 1;
 633   3              }
 634   2          break;
 635   2          
 636   2        }
 637   1        return 2;
 638   1      }
 639          
 640          void CheckButton(void)
 641          {
 642   1        u8 tpv;
 643   1        u16 timout=0;
 644   1        u8 n1=0,n2=0;
 645   1        if (GetDriverBoardReturn==0) return;
 646   1      
 647   1        if (ABEncoderDir==1)
 648   1        {
 649   2          ABEncoderDir=0;
 650   2          if (LCD_DISPiD==1)
 651   2          {
 652   3            if (SaveLedData0.LedOnOff==1)
 653   3            {
 654   4              tpv=SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel];
 655   4              if (tpv<(100-ABEncoderAAC)) tpv+=ABEncoderAAC; else tpv=100;
 656   4              ABEncoderACCCounter=0;
 657   4              if (ABEncoderAAC<10) ABEncoderAAC++;
 658   4              SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel]=tpv;
 659   4              SaveLedData0.Saveed=0;
 660   4              UpdateLcdPowerDisplay(SaveLedData0.SelectedLedChanel,tpv,1);
 661   4              WriteDriverAddressValue(0x13+SaveLedData0.SelectedLedChanel,tpv);
 662   4            }
 663   3            else 
 664   3            { 
 665   4              SelectChDelayCounter=0;
 666   4              tpv=SaveLedData0.SelectedLedChanel;
 667   4              UpdateLCDLEDSelected(tpv,0);
 668   4              if (tpv<(SaveLedData0.LedALLChanels)) tpv++; else tpv=1;
 669   4              SaveLedData0.SelectedLedChanel=tpv;
 670   4              UpdateLCDLEDSelected(tpv,1);
 671   4              MovetoOtherLedch=1;
 672   4            }
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 12  

 673   3          }
 674   2          else 
 675   2          {
 676   3            if (LCD_DISPiD==2)
 677   3            {
 678   4              if (SaveLedData0.LedALLChanels<4) SaveLedData0.LedALLChanels++; 
 679   4              DispSettingNumber(LCD_DISPiD,SaveLedData0.LedALLChanels);
 680   4              SaveLedData0.SelectedLedChanel=1;
 681   4            }
 682   3            else if (LCD_DISPiD==3)
 683   3            {
 684   4              tpv=SaveLedData0.MotorStepPluses;
 685   4              if (tpv<(255-ABEncoderAAC)) tpv+=ABEncoderAAC; else tpv=255;
 686   4              SaveLedData0.MotorStepPluses=tpv;
 687   4              ABEncoderACCCounter=0;
 688   4              if (ABEncoderAAC<10) ABEncoderAAC++;
 689   4              DispSettingNumber(LCD_DISPiD,tpv);
 690   4              WriteDriverAddressValue(0X1d,tpv);
 691   4            }
 692   3            
 693   3            else if (LCD_DISPiD>3 && LCD_DISPiD<=7)
 694   3            {
 695   4              tpv=SaveLedData0.LEDMotorLocation[LCD_DISPiD-3];
 696   4              if (tpv<254) tpv+=1; else tpv=255;
 697   4              //if (tpv<(255-ABEncoderAAC)) tpv+=ABEncoderAAC; else tpv=255;
 698   4              //ABEncoderACCCounter=0;
 699   4              //if (ABEncoderAAC<10) ABEncoderAAC++;
 700   4              SaveLedData0.LEDMotorLocation[LCD_DISPiD-3]=tpv;
 701   4              DispSettingNumber(LCD_DISPiD,tpv);
 702   4              WriteDriverAddressValue(0X16+LCD_DISPiD-1,tpv);
 703   4              WriteDriverAddressValue2(0X11,LCD_DISPiD-3,1); //选择LED，点亮LED
 704   4            }
 705   3            else if (LCD_DISPiD==8)
 706   3            {
 707   4              SaveLedData0.DriverFanOnOff=1;
 708   4              DispSettingNumber(2,1);
 709   4              WriteDriverAddressValue(0X1e,1);
 710   4            }
 711   3          }
 712   2      
 713   2        }
 714   1        
 715   1        else if (ABEncoderDir==0xff)
 716   1        {
 717   2          ABEncoderDir=0;
 718   2          if (LCD_DISPiD==1)
 719   2          {
 720   3            
 721   3            if (SaveLedData0.LedOnOff==1)
 722   3            {
 723   4              tpv=SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel];
 724   4              if (tpv>ABEncoderAAC) tpv-=ABEncoderAAC; else tpv=1;
 725   4              ABEncoderACCCounter=0;
 726   4              if (ABEncoderAAC<10) ABEncoderAAC++;
 727   4              SaveLedData0.LedPower[SaveLedData0.SelectedLedChanel]=tpv;
 728   4              SaveLedData0.Saveed=0;
 729   4              UpdateLcdPowerDisplay(SaveLedData0.SelectedLedChanel,tpv,1);
 730   4              WriteDriverAddressValue(0x13+SaveLedData0.SelectedLedChanel,tpv);
 731   4            }
 732   3            else 
 733   3            {
 734   4              SelectChDelayCounter=0;
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 13  

 735   4              tpv=SaveLedData0.SelectedLedChanel;
 736   4              UpdateLCDLEDSelected(tpv,0);
 737   4              if (tpv>1) tpv--; else tpv=SaveLedData0.LedALLChanels;
 738   4              SaveLedData0.SelectedLedChanel=tpv;
 739   4              UpdateLCDLEDSelected(tpv,1);
 740   4              MovetoOtherLedch=1;
 741   4            }
 742   3          }
 743   2          else 
 744   2          {
 745   3            if (LCD_DISPiD==2)
 746   3            {
 747   4              if (SaveLedData0.LedALLChanels>1) SaveLedData0.LedALLChanels--; 
 748   4              DispSettingNumber(LCD_DISPiD,SaveLedData0.LedALLChanels);
 749   4            }
 750   3            else if (LCD_DISPiD==3)
 751   3            {
 752   4              tpv=SaveLedData0.MotorStepPluses;
 753   4          
 754   4              if (tpv>(ABEncoderAAC+1)) tpv-=ABEncoderAAC; else tpv=1;
 755   4              SaveLedData0.MotorStepPluses=tpv;
 756   4              ABEncoderACCCounter=0;
 757   4              if (ABEncoderAAC<10) ABEncoderAAC++;
 758   4              DispSettingNumber(LCD_DISPiD,tpv);
 759   4              WriteDriverAddressValue(0X1d,tpv);  //设置LED 每步脉冲
 760   4            }
 761   3            else if (LCD_DISPiD>3 && LCD_DISPiD<=7)
 762   3            {
 763   4              tpv=SaveLedData0.LEDMotorLocation[LCD_DISPiD-3];
 764   4              if (tpv>0) tpv-=1; else tpv=0;
 765   4            //  if (tpv>ABEncoderAAC) tpv-=ABEncoderAAC; else tpv=0;
 766   4            //  ABEncoderACCCounter=0;
 767   4            //  if (ABEncoderAAC<10) ABEncoderAAC++;
 768   4              SaveLedData0.LEDMotorLocation[LCD_DISPiD-3]=tpv;
 769   4              DispSettingNumber(LCD_DISPiD,tpv);
 770   4              WriteDriverAddressValue(0X16+LCD_DISPiD-1,tpv);//发送led 位置信息
 771   4              WriteDriverAddressValue2(0X11,LCD_DISPiD-3,1);//发送选择的led 和 开灯
 772   4          
 773   4            }
 774   3            else if (LCD_DISPiD==8)
 775   3            {
 776   4              SaveLedData0.DriverFanOnOff=0;
 777   4              DispSettingNumber(2,0);
 778   4              WriteDriverAddressValue(0X1e,0);
 779   4            }
 780   3          }
 781   2        }
 782   1      
 783   1        if (P32==0)//编码器按键
 784   1          {
 785   2          delay_ms(5);
 786   2          if (P32==0)
 787   2          {
 788   3          /*
 789   3            for (tpv=0;tpv<100;tpv++)
 790   3              {
 791   3              delay_ms(30);
 792   3              if (P32==1) break;
 793   3              }
 794   3            if(P32==0)
 795   3              {
 796   3              DisplaySetting();
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 14  

 797   3              Beep();  //进入设置界面
 798   3              }
 799   3            else*/
 800   3              {
 801   4              Beep();
 802   4              if (LCD_DISPiD==1)// && GetDriverBoardReturn==1)
 803   4                {
 804   5                if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
 805   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 806   5                }
 807   4              else if (LCD_DISPiD>=2)
 808   4                {
 809   5                LCD_DISPiD++; 
 810   5                if (LCD_DISPiD==3) 
 811   5                  {
 812   6                  DispSettingRectangle();
 813   6                  WriteDriverAddressValue(0X1d,SaveLedData0.MotorStepPluses);  //设置LED 每步脉冲
 814   6                  }
 815   5                else if (LCD_DISPiD<=7) 
 816   5                  {
 817   6                  DispSettingRectangle();
 818   6                  WriteDriverAddressValue2(0X11,LCD_DISPiD-3,1);// update led selection and on off
 819   6                  }
 820   5                else if (LCD_DISPiD==8) //driver fan onoff
 821   5                  {
 822   6                  DisplaySetting2();
 823   6                  }
 824   5                else 
 825   5                  {
 826   6                  LCD_DISPiD=1;
 827   6                  LCD_DrawWorkScreen();
 828   6                  NeedSaveData=1;  //需要保存
 829   6                  WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 830   6                  }
 831   5                
 832   5                }
 833   4              }
 834   3      
 835   3            while (P32==0) 
 836   3              {
 837   4              WDTRST;
 838   4              while (P32==0)  delay_ms(5);
 839   4              }
 840   3          }
 841   2        }
 842   1      
 843   1      
 844   1      /*
 845   1        
 846   1        if (ABEncoderDir==1)
 847   1        {
 848   1          ABEncoderDir=2;
 849   1          
 850   1        }
 851   1        else if (ABEncoderDir==0xff)
 852   1        {
 853   1          ABEncoderDir=2;
 854   1          
 855   1        }
 856   1         */
 857   1      
 858   1      //   ABEncoderStep=;
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 15  

 859   1         if ((P3&0X88)==0x88) ABEncoderDir=0;
 860   1      
 861   1      
 862   1        
 863   1      
 864   1        if (P26==0)
 865   1        {
 866   2          delay_ms(5);
 867   2          if (P26==0)
 868   2          {
 869   3            Beep();
 870   3              if (LCD_DISPiD==1)
 871   3               {
 872   4                if (SaveLedData0.SelectedLedChanel==1)
 873   4                {
 874   5                  if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
 875   5                  WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 876   5                }
 877   4                else
 878   4                {
 879   5                  UpdateSelcetedLed(1);
 880   5                  UpdateSelectedLedOnOff(1); 
 881   5                  WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 882   5                }
 883   4               }
 884   3            
 885   3              while (P26==0) 
 886   3              {
 887   4              WDTRST;
 888   4              while (P26==0)  
 889   4                {
 890   5                
 891   5                if (P01==0)
 892   5                  {
 893   6                  for (tpv=0;tpv<100;tpv++)
 894   6                  {
 895   7                    delay_ms(30);
 896   7                    if (P26!=0 || P01!=0) break;
 897   7                    }
 898   6                    if (P26==0 && P01==0)
 899   6                      {
 900   7                      DisplaySetting();
 901   7                      Beep();  //进入设置界面
 902   7                      }
 903   6                    while (P26==0 || P01==0) 
 904   6                    {
 905   7                    WDTRST;
 906   7                    while (P26==0 || P01==0)  delay_ms(5);
 907   7                  }
 908   6                  }
 909   5                else 
 910   5                  delay_ms(5);
 911   5                }
 912   4              }
 913   3            }
 914   2        }
 915   1        
 916   1        if (P27==0)
 917   1        {
 918   2          delay_ms(5);
 919   2          if (P27==0)
 920   2          {
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 16  

 921   3            Beep();
 922   3            if (LCD_DISPiD==1)
 923   3             {
 924   4              if (SaveLedData0.SelectedLedChanel==2)
 925   4              {
 926   5                if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
 927   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 928   5              }
 929   4              else  if (SaveLedData0.LedALLChanels>1)
 930   4              {
 931   5                UpdateSelcetedLed(2);
 932   5                UpdateSelectedLedOnOff(1); 
 933   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 934   5              }
 935   4      
 936   4            }
 937   3            while (P27==0) 
 938   3              {
 939   4              WDTRST;
 940   4              while (P27==0)  delay_ms(5);
 941   4              }
 942   3          }
 943   2        }
 944   1      
 945   1        if (P00==0)
 946   1        {
 947   2          delay_ms(5);
 948   2          if (P00==0)
 949   2          {
 950   3            Beep();
 951   3            if (LCD_DISPiD==1)
 952   3            {
 953   4              if (SaveLedData0.SelectedLedChanel==3)
 954   4              {
 955   5                if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
 956   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 957   5              }
 958   4              else if (SaveLedData0.LedALLChanels>2)
 959   4              {
 960   5                UpdateSelcetedLed(3);
 961   5                UpdateSelectedLedOnOff(1); 
 962   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 963   5              }
 964   4            }
 965   3            while (P00==0) 
 966   3              {
 967   4              WDTRST;
 968   4              while (P00==0)  delay_ms(5);
 969   4              }
 970   3          }
 971   2        }
 972   1      
 973   1        if (P01==0)
 974   1        {
 975   2          delay_ms(5);
 976   2          if (P01==0)
 977   2          {
 978   3            Beep();
 979   3            
 980   3            if (LCD_DISPiD==1)
 981   3            {
 982   4              if (SaveLedData0.SelectedLedChanel==4)
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 17  

 983   4              {
 984   5                if (SaveLedData0.LedOnOff)  UpdateSelectedLedOnOff(0); else UpdateSelectedLedOnOff(1); 
 985   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel,SaveLedData0.LedOnOff);
 986   5              }
 987   4              else if (SaveLedData0.LedALLChanels>3)
 988   4              {
 989   5                UpdateSelcetedLed(4);
 990   5                UpdateSelectedLedOnOff(1); 
 991   5                WriteDriverAddressValue2(0X11,SaveLedData0.SelectedLedChanel, SaveLedData0.LedOnOff);
 992   5              }
 993   4            }
 994   3            while (P01==0) 
 995   3              {
 996   4              WDTRST;
 997   4              while (P01==0) 
 998   4                {
 999   5                if (P26==0)
1000   5                  {
1001   6                  for (tpv=0;tpv<100;tpv++)
1002   6                  {
1003   7                  delay_ms(30);
1004   7                  if (P26!=0 || P01!=0) break;
1005   7                  }
1006   6                  if (P26==0 && P01==0)
1007   6                    {
1008   7                    DisplaySetting();
1009   7                    Beep();  //进入设置界面
1010   7                    }
1011   6                  while (P26==0 || P01==0) 
1012   6                    {
1013   7                    WDTRST;
1014   7                    while (P26==0 || P01==0)  delay_ms(5);
1015   7                    }
1016   6                  }
1017   5                else 
1018   5                  delay_ms(5);
1019   5                }
1020   4              }
1021   3          }
1022   2        }
1023   1      
1024   1      
1025   1        if (UsbCmdUpdate!=0)
1026   1        {
1027   2          UsbCmdUpdate=0;
1028   2          DoUart4CmdPro();
1029   2        }
1030   1      }
1031          
1032          void ExClockConfig(void)
1033          {
1034   1      // u32 timeoutcounter=0;
1035   1        P_SW2 = 0x80;
1036   1        XOSCCR = 0xc0;                //???ˉía2??§??
1037   1        while (!(XOSCCR & 1) ) 
1038   1          {
1039   2          WDTRST;        //μè′yê±?ó?è?¨
1040   2          }
1041   1        CLKDIV = 0x00;                 //ê±?ó2?・??μ
1042   1        CKSEL = 0x01;               //????ía2??§??
1043   1        P_SW2 = 0x00;
1044   1      }
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 18  

1045          
1046          
1047          void main()
1048          {
1049   1        
1050   1        ExClockConfig();
1051   1        if(CmpDataFlashUuid()==0) while (1);
1052   1        Gpio_Init();
1053   1        Uart2Init();   //DRIVER BOARD
1054   1        Uart4Init();  //USB
1055   1        lcd_initial();
1056   1        Timer0Init();
1057   1        SPI_FLASH_Init();
1058   1        delay_ms(100);
1059   1        Gui_DrawFlashbmp16(0,0,0);
1060   1      //  
1061   1      //  Display_ASCII8X16(50,16,"EasyLWL",7,BLUE);
1062   1        CtrlLcdBL(1);
1063   1        EA=1;
1064   1        ReadDriverAddressValue(0x10,1);
1065   1        Beep();
1066   1        ReadEEpromSaveData();
1067   1        ReadDriverAddressValue(0x10,1);
1068   1      
1069   1        //开机加载画
1070   1        while (StartDelayCounter<MAXSTARTDELAYTIME)  //等待开机停留时间, lcd 应答
1071   1          {
1072   2          WDTRST;  
1073   2          if ((StartDelayCounter>=MINSTARTDELAYTIME) &&(GetDriverBoardReturn!=0)) break;
1074   2          if (NeedUpdateLEDValue)
1075   2          {
1076   3          NeedUpdateLEDValue=0;
1077   3          GetDriverBoardReturn=0;
1078   3          ReadDriverAddressValue(0x10,1); //心跳包
1079   3          }
1080   2          DoUart2Pkg();  //driver board
1081   2          }
1082   1        
1083   1        NeedUpdateConnect=0;
1084   1        InitLcd();
1085   1        WriteDriverSqAddressValue(0X10,&(SaveLedData0.DriverType),sizeof(Run_PARAMS));
1086   1        /* Infinite loop */
1087   1        while (1)
1088   1        {
1089   2          WDTRST;                      //清看门狗,否则系统复位
1090   2          DoUart2Pkg();  //driver board
1091   2          //DoUart4Pkg();   //usb uart4 interrupt sub run 
1092   2        CheckButton();
1093   2        HandleLCD();
1094   2        }
1095   1      }
1096          
1097          
1098          
1099          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5180    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    348    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.56.0.0   MAIN                                                              07/07/2023 23:29:01 PAGE 19  

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
